<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –¢–†–ò–ó</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: #0a0a0f;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        :root {
            /* –ö—Ä–∞—Å–Ω–∞—è —Ç–µ–º–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ */
            --accentRgb: 255, 55, 55;
            --accentRgb2: 255, 120, 120;
        }
        
        /* –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 80, 80, 0.16) 0%, transparent 52%),
                radial-gradient(circle at 80% 70%, rgba(255, 140, 140, 0.10) 0%, transparent 52%),
                radial-gradient(circle at 50% 50%, rgba(255, 60, 60, 0.08) 0%, transparent 60%),
                linear-gradient(135deg, #140607 0%, #2a0a0f 25%, #1b0b10 50%, #2d0a0a 75%, #140607 100%);
            background-size: 100% 100%, 100% 100%, 100% 100%, 400% 400%;
            animation: gradientShift 20s ease infinite, radialPulse 15s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
            opacity: 0.9;
        }
        
        @keyframes gradientShift {
            0% {
                background-position: 0% 50%, 0% 0%, 0% 0%, 0% 50%;
            }
            50% {
                background-position: 100% 50%, 100% 100%, 50% 50%, 100% 50%;
            }
            100% {
                background-position: 0% 50%, 0% 0%, 0% 0%, 0% 50%;
            }
        }
        
        @keyframes radialPulse {
            0%, 100% {
                opacity: 0.9;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }
        
        /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ—Ç–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è –≥–ª—É–±–∏–Ω—ã */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 30% 20%, rgba(255, 120, 120, 0.09) 0%, transparent 42%),
                radial-gradient(ellipse at 70% 80%, rgba(255, 70, 70, 0.07) 0%, transparent 42%);
            animation: lightDrift 25s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes lightDrift {
            0%, 100% {
                transform: translate(0, 0) scale(1);
                opacity: 0.8;
            }
            33% {
                transform: translate(5%, 3%) scale(1.1);
                opacity: 1;
            }
            66% {
                transform: translate(-3%, -2%) scale(0.95);
                opacity: 0.9;
            }
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .controls-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 25, 0.92);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(var(--accentRgb), 0.22);
            border-radius: 20px;
            padding: 14px 24px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(var(--accentRgb), 0.12) inset;
            display: flex;
            gap: 14px;
            align-items: center;
            z-index: 100;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95%;
        }

        .face-controls-panel {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 25, 0.92);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(var(--accentRgb), 0.22);
            border-radius: 20px;
            padding: 14px 24px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(var(--accentRgb), 0.12) inset;
            display: none;
            gap: 14px;
            align-items: center;
            z-index: 100;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95%;
        }

        .face-controls-panel.active {
            display: flex;
        }

        .face-controls-panel .label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-right: 8px;
            font-weight: 300;
        }

        .btn-face {
            background: rgba(var(--accentRgb), 0.14);
            border: 1px solid rgba(var(--accentRgb), 0.35);
            color: rgba(255, 255, 255, 0.9);
        }

        .btn-face:hover {
            background: rgba(var(--accentRgb), 0.22);
            border-color: rgba(var(--accentRgb), 0.5);
        }

        .btn-face:active {
            background: rgba(var(--accentRgb), 0.28);
        }

        /* –°–ø–∏—Å–æ–∫ –≥—Ä–∞–Ω–µ–π (–Ω–æ–º–µ—Ä–∞ 1‚Äì12) */
        .face-list {
            position: fixed;
            top: 50%;
            right: 24px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(15, 20, 35, 0.96);
            border-radius: 18px;
            box-shadow: 0 12px 36px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.18);
            z-index: 150; /* –≤—ã—à–µ –ø–∞–Ω–µ–ª–∏ –∏ –ø–æ–¥—Å–∫–∞–∑–æ–∫ */
            max-height: 80%;
            overflow-y: auto;
            scrollbar-width: none;
        }

        .face-list::-webkit-scrollbar {
            display: none;
        }

        .face-list-item {
            min-width: 36px;
            height: 36px;
            border-radius: 10px;
            border: 1px solid rgba(var(--accentRgb), 0.28);
            background: rgba(30, 35, 50, 0.6);
            color: rgba(255, 255, 255, 0.85);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0 10px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .face-list-item:hover {
            background: rgba(50, 70, 100, 0.7);
            border-color: rgba(var(--accentRgb), 0.55);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 0 18px rgba(var(--accentRgb), 0.22);
        }

        .face-list-item.active {
            background: linear-gradient(135deg, rgba(var(--accentRgb), 0.96) 0%, rgba(var(--accentRgb2), 0.96) 100%);
            border-color: rgba(var(--accentRgb), 1);
            color: #0a0a0f;
            font-weight: 700;
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(var(--accentRgb), 0.45), 0 0 28px rgba(var(--accentRgb), 0.32);
        }

        .control-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .control-group label {
            display: none;
        }

        /* –°–∫—Ä—ã—Ç–∏–µ –∫–Ω–æ–ø–æ–∫ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö */
        @media (max-width: 768px) {
            .desktop-only {
                display: none !important;
            }
        }

        .btn {
            background: rgba(30, 35, 50, 0.7);
            border: 1px solid rgba(var(--accentRgb), 0.28);
            color: rgba(255, 255, 255, 0.95);
            width: 48px;
            height: 48px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 0 0 0 rgba(var(--accentRgb), 0);
        }

        .btn:hover {
            background: rgba(50, 70, 100, 0.8);
            border-color: rgba(var(--accentRgb), 0.6);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 20px rgba(var(--accentRgb), 0.28);
        }

        .btn:active {
            transform: translateY(0) scale(0.98);
            background: rgba(70, 100, 150, 0.9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 12px rgba(var(--accentRgb), 0.22);
        }

        .title {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.98);
            font-size: 36px;
            font-weight: 700;
            letter-spacing: 3px;
            z-index: 100;
            text-align: center;
            text-shadow: 0 2px 20px rgba(var(--accentRgb), 0.35), 0 0 40px rgba(var(--accentRgb), 0.18);
            background: linear-gradient(135deg, rgba(255, 245, 245, 0.98) 0%, rgba(var(--accentRgb2), 0.92) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .info {
            display: none;
        }

        @media (max-width: 768px) {
            .face-list {
                top: auto;
                bottom: 20px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                flex-direction: row;
                max-width: 95%;
                max-height: none;
                padding: 8px 12px;
            }
            
            .controls-panel {
                display: none; /* –°–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
            }
            
            /* –ö–Ω–æ–ø–∫–∞ —Å–±—Ä–æ—Å–∞ –≤–≤–µ—Ä—Ö –≤–ø—Ä–∞–≤–æ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
            #reset {
                position: fixed !important;
                top: 20px !important;
                right: 20px !important;
                bottom: auto !important;
                left: auto !important;
                transform: none !important;
                z-index: 1000;
            }
            
            /* –°–∫—Ä—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≥—Ä–∞–Ω—å—é –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
            .face-controls-panel {
                display: none !important;
            }

            .btn {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }

            .title {
                font-size: 28px;
                top: 16px;
                letter-spacing: 2px;
            }

            .control-group {
                gap: 6px;
            }
        }

        @media (max-width: 480px) {
            .controls-panel {
                bottom: 8px;
                padding: 8px 10px;
                gap: 6px;
            }

            .btn {
                width: 44px;
                height: 44px;
                font-size: 18px;
            }

            .title {
                font-size: 22px;
                top: 12px;
                letter-spacing: 1.5px;
            }
        }

        .separator {
            display: none;
        }

        .hint-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 32px 40px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            max-width: 90%;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        .hint-notification.show {
            opacity: 1;
            pointer-events: auto;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 50% 45%, rgba(var(--accentRgb), 0.14) 0%, transparent 55%),
                radial-gradient(circle at 50% 70%, rgba(var(--accentRgb2), 0.10) 0%, transparent 60%),
                #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 24px;
            letter-spacing: 1px;
        }

        /* –ù–æ–≤—ã–π –ª–æ–∞–¥–µ—Ä: –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏ —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫–∞ */
        .hex-loader {
            width: 140px;
            height: 140px;
            margin: 0 0 14px 0;
            filter: drop-shadow(0 0 18px rgba(var(--accentRgb), 0.25));
        }

        .hex-loader svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .hex-base {
            fill: none;
            stroke: rgba(var(--accentRgb), 0.22);
            stroke-width: 6;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .hex-progress {
            fill: none;
            stroke: rgba(var(--accentRgb), 0.95);
            stroke-width: 6;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 400;
            stroke-dashoffset: 400;
            transition: stroke-dashoffset 0.25s ease;
            filter: drop-shadow(0 0 10px rgba(var(--accentRgb), 0.35));
        }

        .hex-scan {
            fill: none;
            stroke: rgba(var(--accentRgb2), 0.95);
            stroke-width: 6;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 26 18;
            animation: hexScan 1.15s linear infinite;
            opacity: 0.9;
        }

        @keyframes hexScan {
            0% { stroke-dashoffset: 0; opacity: 0.75; }
            50% { opacity: 1; }
            100% { stroke-dashoffset: -220; opacity: 0.75; }
        }

        .progress-percent {
            color: rgba(var(--accentRgb2), 0.9);
            font-size: 14px;
            margin-top: 12px;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .loading-text {
                font-size: 20px;
            }

            .hex-loader {
                width: 120px;
                height: 120px;
            }
        }

        .hint-notification h3 {
            color: rgba(255, 255, 255, 0.95);
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 20px;
            letter-spacing: 1px;
        }

        .hint-notification p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .hint-notification .hint-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.8;
        }

        .hint-notification .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
        }

        .hint-notification .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 768px) {
            .hint-notification {
                padding: 24px 28px;
                border-radius: 16px;
            }

            .hint-notification h3 {
                font-size: 20px;
                margin-bottom: 16px;
            }

            .hint-notification p {
                font-size: 14px;
                margin-bottom: 10px;
            }

            .hint-notification .hint-icon {
                font-size: 36px;
                margin-bottom: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="title">3D –¢–†–ò–ó</div>
    <div id="canvas-container"></div>
    
    <div class="face-list" id="face-list"></div>
    
    <!-- –û–≤–µ—Ä–ª–µ–π –∑–∞–≥—Ä—É–∑–∫–∏ -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-text">–ó–∞–≥—Ä—É–∑–∫–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤..</div>
        <div class="hex-loader" aria-label="–ó–∞–≥—Ä—É–∑–∫–∞">
            <svg viewBox="-60 -60 120 120" role="img" aria-hidden="true">
                <!-- –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫ -->
                <polygon class="hex-base" points="0,-48 41.57,-24 41.57,24 0,48 -41.57,24 -41.57,-24"></polygon>
                <!-- –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–æ –æ–±–≤–æ–¥–∫–µ (—É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –∏–∑ JS) -->
                <polygon class="hex-progress" id="hex-progress" points="0,-48 41.57,-24 41.57,24 0,48 -41.57,24 -41.57,-24"></polygon>
                <!-- –¥–∏–Ω–∞–º–∏—á–Ω–∞—è "–±–µ–≥—É—â–∞—è" –ª–∏–Ω–∏—è –ø–æ–≤–µ—Ä—Ö -->
                <polygon class="hex-scan" points="0,-48 41.57,-24 41.57,24 0,48 -41.57,24 -41.57,-24"></polygon>
            </svg>
        </div>
        <div class="progress-percent" id="progress-percent">0%</div>
    </div>

    <div class="controls-panel">
        <button class="btn desktop-only" id="zoom-in" title="–ü—Ä–∏–±–ª–∏–∑–∏—Ç—å">+</button>
        <button class="btn desktop-only" id="zoom-out" title="–û—Ç–¥–∞–ª–∏—Ç—å">‚àí</button>
        <button class="btn" id="reset" title="–°–±—Ä–æ—Å–∏—Ç—å –≤–∏–¥">‚ü≤</button>
    </div>

    <div class="face-controls-panel" id="face-controls-panel">
        <span class="label desktop-only">–í—Ä–∞—â–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏:</span>
        <button class="btn btn-face desktop-only" id="face-rotate-left" title="–í—Ä–∞—â–∞—Ç—å –≥—Ä–∞–Ω—å –≤–ª–µ–≤–æ">‚Ü∫</button>
        <button class="btn btn-face desktop-only" id="face-rotate-right" title="–í—Ä–∞—â–∞—Ç—å –≥—Ä–∞–Ω—å –≤–ø—Ä–∞–≤–æ">‚Üª</button>
        <button class="btn btn-face" id="face-deselect" title="–°–Ω—è—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ">‚úï</button>
    </div>

    <div class="texture-controls-panel" id="texture-controls-panel" style="position: fixed; top: 120px; left: 20px; background: rgba(30, 30, 40, 0.95); padding: 15px; border-radius: 8px; display: none !important; visibility: hidden; z-index: -1; color: white; font-size: 12px; border: 1px solid rgba(100, 150, 255, 0.3); max-width: 300px;">
        <div style="margin-bottom: 10px; font-weight: bold;">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä–æ–π –≥—Ä–∞–Ω–∏ <span id="texture-face-number">1</span>:</div>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
            <span style="min-width: 80px;">–ü–æ–≤–æ—Ä–æ—Ç:</span>
            <button class="btn btn-face" id="texture-rotate-left" title="–ü–æ–≤–µ—Ä–Ω—É—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É –≤–ª–µ–≤–æ">‚Ü∫</button>
            <button class="btn btn-face" id="texture-rotate-right" title="–ü–æ–≤–µ—Ä–Ω—É—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É –≤–ø—Ä–∞–≤–æ">‚Üª</button>
            <span id="texture-rotation-value" style="min-width: 60px; text-align: center;">0¬∞</span>
        </div>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
            <span style="min-width: 80px;">–°–º–µ—â–µ–Ω–∏–µ X:</span>
            <button class="btn btn-face" id="texture-offset-x-left" title="–°–º–µ—Å—Ç–∏—Ç—å –≤–ª–µ–≤–æ">‚Üê</button>
            <button class="btn btn-face" id="texture-offset-x-right" title="–°–º–µ—Å—Ç–∏—Ç—å –≤–ø—Ä–∞–≤–æ">‚Üí</button>
            <span id="texture-offset-x-value" style="min-width: 60px; text-align: center;">0.00</span>
        </div>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
            <span style="min-width: 80px;">–°–º–µ—â–µ–Ω–∏–µ Y:</span>
            <button class="btn btn-face" id="texture-offset-y-down" title="–°–º–µ—Å—Ç–∏—Ç—å –≤–Ω–∏–∑">‚Üì</button>
            <button class="btn btn-face" id="texture-offset-y-up" title="–°–º–µ—Å—Ç–∏—Ç—å –≤–≤–µ—Ä—Ö">‚Üë</button>
            <span id="texture-offset-y-value" style="min-width: 60px; text-align: center;">0.00</span>
        </div>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
            <span style="min-width: 80px;">–ú–∞—Å—à—Ç–∞–±:</span>
            <button class="btn btn-face" id="texture-scale-down" title="–£–º–µ–Ω—å—à–∏—Ç—å">‚àí</button>
            <button class="btn btn-face" id="texture-scale-up" title="–£–≤–µ–ª–∏—á–∏—Ç—å">+</button>
            <span id="texture-scale-value" style="min-width: 60px; text-align: center;">1.00</span>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
            <button class="btn btn-face" id="texture-reset" style="width: 100%;">–°–±—Ä–æ—Å–∏—Ç—å</button>
            <button class="btn btn-face" id="texture-copy-values" style="width: 100%; margin-top: 5px; background: #4CAF50;">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è</button>
        </div>
        <div id="texture-values-output" style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-family: monospace; font-size: 10px; word-break: break-all; max-height: 100px; overflow-y: auto;"></div>
    </div>

    <div class="hint-notification" id="hint-notification" style="display: none !important;">
        <button class="close-btn" id="close-hint">√ó</button>
        <div class="hint-icon">üîÑ</div>
        <h3>–ö–∞–∫ –≤—Ä–∞—â–∞—Ç—å –º–æ–¥–µ–ª—å</h3>
        <p id="hint-text-desktop">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –º—ã—à—å—é –ø–æ –º–æ–¥–µ–ª–∏, —á—Ç–æ–±—ã –≤—Ä–∞—â–∞—Ç—å –µ—ë</p>
        <p id="hint-text-mobile" style="display: none;">–ü—Ä–æ–≤–µ–¥–∏—Ç–µ –ø–∞–ª—å—Ü–µ–º –ø–æ —ç–∫—Ä–∞–Ω—É, —á—Ç–æ–±—ã –≤—Ä–∞—â–∞—Ç—å –º–æ–¥–µ–ª—å</p>
        <p style="font-size: 14px; opacity: 0.6; margin-top: 16px;">–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏ –∏–ª–∏ –∂–µ—Å—Ç—ã –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (–Ω—É–∂–Ω–æ –î–û –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ renderer)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 7); // –ù–∞—á–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ —É–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –±–æ–ª–µ–µ –æ—Ç–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –≤–∏–¥–∞
        camera.lookAt(0, 0, 0); // –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –∫–∞–º–µ—Ä–µ —Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —Ü–µ–Ω—Ç—Ä —Å—Ü–µ–Ω—ã

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        
        // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ WebGL
        const gl = renderer.getContext();
        const originalGetError = gl.getError;
        let errorCount = 0;
        gl.getError = function() {
            const error = originalGetError.call(this);
            if (error !== gl.NO_ERROR && errorCount < 10) { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–≥–æ–≤
                errorCount++;
                const errorNames = {
                    [gl.NO_ERROR]: 'NO_ERROR',
                    [gl.INVALID_ENUM]: 'INVALID_ENUM',
                    [gl.INVALID_VALUE]: 'INVALID_VALUE',
                    [gl.INVALID_OPERATION]: 'INVALID_OPERATION',
                    [gl.INVALID_FRAMEBUFFER_OPERATION]: 'INVALID_FRAMEBUFFER_OPERATION',
                    [gl.OUT_OF_MEMORY]: 'OUT_OF_MEMORY',
                    [gl.CONTEXT_LOST_WEBGL]: 'CONTEXT_LOST_WEBGL'
                };
                const errorName = errorNames[error] || `UNKNOWN(${error})`;
                console.error(`[WebGL Error ${errorCount}] ${errorName}`);
            }
            return error;
        };
        
        // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ –∫–æ–Ω—Å–æ–ª–∏
        const originalError = console.error;
        console.error = function(...args) {
            originalError.apply(console, args);
            const errorStr = args.map(a => String(a)).join(' ');
            if (errorStr.includes('SecurityError') || errorStr.includes('Tainted') || errorStr.includes('texImage2D') || errorStr.includes('GL_INVALID')) {
            }
        };
        renderer.setSize(window.innerWidth, window.innerHeight);
        // –ö–∞—á–µ—Å—Ç–≤–æ —Ä–µ–Ω–¥–µ—Ä–∞: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º DPR, —á—Ç–æ–±—ã –±—ã–ª–æ —Ä–µ–∑–∫–æ, –Ω–æ –Ω–µ —É–±–∏–≤–∞–ª–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        const maxDPR = isMobile ? 1.25 : 2.0;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, maxDPR));
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —Ç—ë–º–Ω—ã–π —Ñ–æ–Ω
        // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
        renderer.setClearColor(0x0a0a0f, 0.3);
        renderer.shadowMap.enabled = false;
        // –í–∫–ª—é—á–∞–µ–º tone mapping –¥–ª—è –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –≤–∏–¥–∞
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;

        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–Ω–µ–ª—å —Å–ø–∏—Å–∫–∞ –≥—Ä–∞–Ω–µ–π (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –ø–æ–∑–∂–µ)
        let faceListElement = null;
        
        const canvas = renderer.domElement;
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.zIndex = '1'; // –ü–æ–¥ UI —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏, –Ω–æ –≤–∏–¥–µ–Ω
        
        document.getElementById('canvas-container').appendChild(canvas);
        
        
        console.log('–†–µ–Ω–¥–µ—Ä–µ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, —Ä–∞–∑–º–µ—Ä:', window.innerWidth, 'x', window.innerHeight);
        console.log('Canvas —ç–ª–µ–º–µ–Ω—Ç:', canvas);
        console.log('Canvas —Ä–∞–∑–º–µ—Ä—ã:', canvas.width, 'x', canvas.height);
        
        // –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ canvas
        setTimeout(() => {
            const canvasStyle = window.getComputedStyle(canvas);
            const containerStyle = window.getComputedStyle(document.getElementById('canvas-container'));
            console.log('=== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê CANVAS ===');
            console.log('Canvas –≤ DOM:', document.getElementById('canvas-container').contains(canvas));
            console.log('Canvas display:', canvasStyle.display);
            console.log('Canvas visibility:', canvasStyle.visibility);
            console.log('Canvas opacity:', canvasStyle.opacity);
            console.log('Canvas z-index:', canvasStyle.zIndex);
            console.log('Canvas position:', canvasStyle.position);
            console.log('Canvas top:', canvasStyle.top);
            console.log('Canvas left:', canvasStyle.left);
            console.log('Canvas width:', canvasStyle.width);
            console.log('Canvas height:', canvasStyle.height);
            console.log('Container width:', containerStyle.width);
            console.log('Container height:', containerStyle.height);
            console.log('Container position:', containerStyle.position);
            console.log('Container z-index:', containerStyle.zIndex);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ WebGL –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            const gl = renderer.getContext();
            console.log('WebGL –∫–æ–Ω—Ç–µ–∫—Å—Ç:', gl ? '–µ—Å—Ç—å' : '–Ω–µ—Ç');
            if (gl) {
                console.log('WebGL –≤–µ—Ä—Å–∏—è:', gl.getParameter(gl.VERSION));
                console.log('WebGL vendor:', gl.getParameter(gl.VENDOR));
                console.log('WebGL renderer:', gl.getParameter(gl.RENDERER));
            }
        }, 100);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ –¥–ª—è –∫—Ä–∞—Å–∏–≤—ã—Ö —Å–≤–µ—Ç–æ—Ç–µ–Ω–µ–π
        // –ú—è–≥–∫–æ–µ –æ–±—â–µ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ (ambient) - —Å–æ–∑–¥–∞–µ—Ç –±–∞–∑–æ–≤—É—é –≤–∏–¥–∏–º–æ—Å—Ç—å
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambientLight);

        // –û—Å–Ω–æ–≤–Ω–æ–π –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç (–∫–ª—é—á–µ–≤–æ–π —Å–≤–µ—Ç) - —Å–≤–µ—Ä—Ö—É —Å–ª–µ–≤–∞
        // –°–æ–∑–¥–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ —Ç–µ–Ω–∏ –∏ –æ–±—ä–µ–º
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(6, 10, 4);
        mainLight.castShadow = false;
        // –î–æ–±–∞–≤–ª—è–µ–º –ª–µ–≥–∫–∏–π —Ü–≤–µ—Ç–æ–≤–æ–π –æ—Ç—Ç–µ–Ω–æ–∫ –¥–ª—è —Ç–µ–ø–ª–æ—Ç—ã
        mainLight.color.setHex(0xfff8f0);
        scene.add(mainLight);

        // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç (fill light) - —Å–Ω–∏–∑—É —Å–ø—Ä–∞–≤–∞
        // –ú—è–≥–∫–æ –∑–∞–ø–æ–ª–Ω—è–µ—Ç —Ç–µ–Ω–∏, –Ω–µ —Å–æ–∑–¥–∞–≤–∞—è –ø–ª–æ—Å–∫–æ–≥–æ –≤–∏–¥–∞
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-4, -3, -5);
        fillLight.castShadow = false;
        // –õ–µ–≥–∫–∏–π —Ö–æ–ª–æ–¥–Ω—ã–π –æ—Ç—Ç–µ–Ω–æ–∫ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
        fillLight.color.setHex(0xe0f0ff);
        scene.add(fillLight);

        // –†–∏–º—Å–∫–∏–π —Å–≤–µ—Ç (rim light) - —Å–∑–∞–¥–∏ –¥–ª—è –∫–æ–Ω—Ç—É—Ä–∞
        // –ü–æ–¥—á–µ—Ä–∫–∏–≤–∞–µ—Ç –∫—Ä–∞—è —Ñ–∏–≥—É—Ä—ã, –¥–æ–±–∞–≤–ª—è–µ—Ç –≥–ª—É–±–∏–Ω—É
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
        rimLight.position.set(-2, 2, -8);
        rimLight.castShadow = false;
        rimLight.color.setHex(0xb8d4ff);
        scene.add(rimLight);
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –¥–ª—è –∞–∫—Ü–µ–Ω—Ç–æ–≤
        const accentLight = new THREE.PointLight(0xffffff, 0.6);
        accentLight.position.set(0, 8, 0);
        accentLight.castShadow = false;
        accentLight.color.setHex(0xffffff);
        scene.add(accentLight);
        
        console.log('–û—Å–≤–µ—â–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Å—Ü–µ–Ω—É');

        // –°–æ–∑–¥–∞–Ω–∏–µ –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞
        const geometry = new THREE.DodecahedronGeometry(1, 0);
        console.log('–ì–µ–æ–º–µ—Ç—Ä–∏—è –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞:', geometry);
        const materials = [];
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –±–µ–ª–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã —Å –Ω–æ–º–µ—Ä–æ–º –≥—Ä–∞–Ω–∏
        function createNumberedTexture(faceNumber) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // –ë–µ–ª—ã–π —Ñ–æ–Ω
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            
            // –ß–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä –≥—Ä–∞–Ω–∏ - —É–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 180px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // –†–∏—Å—É–µ–º –Ω–æ–º–µ—Ä –≤ —Ü–µ–Ω—Ç—Ä–µ, –∑–µ—Ä–∫–∞–ª—å–Ω–æ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏,
            // —á—Ç–æ–±—ã —Å–Ω–∞—Ä—É–∂–∏ –º–æ–¥–µ–ª–∏ —Ç–µ–∫—Å—Ç –±—ã–ª –ù–ï –∑–µ—Ä–∫–∞–ª—å–Ω—ã–π
            ctx.save();
            ctx.translate(512, 0);
            ctx.scale(-1, 1);
            ctx.fillText(faceNumber.toString(), 256, 256);
            ctx.restore();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.flipY = false; // –í–∞–∂–Ω–æ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            return texture;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–≥–ª—É—à–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã
        function createPlaceholderTexture(filename) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(filename.replace('.jpg', ''), 256, 256);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            return texture;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π CORS
        function loadImageAsTexture(filename) {
            return new Promise((resolve, reject) => {
                
                const maxAnisotropy = renderer.capabilities && renderer.capabilities.getMaxAnisotropy
                    ? renderer.capabilities.getMaxAnisotropy()
                    : 1;
                const anisotropy = Math.min(8, maxAnisotropy || 1); // 8 –æ–±—ã—á–Ω–æ —Ö–≤–∞—Ç–∞–µ—Ç, –≤—ã—à–µ —Ä–µ–¥–∫–æ –∑–∞–º–µ—Ç–Ω–æ
                
                const textureLoader = new THREE.TextureLoader();
                
                // –î–ª—è file:// –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –ø—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏
                const isFileProtocolLocal = window.location.protocol === 'file:';
                let texturePath = filename;
                
                if (isFileProtocolLocal) {
                    // –î–ª—è file:// —Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
                    const currentDir = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                    texturePath = `${currentDir}${filename}`;
                    console.log(`[file://] –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å —á–µ—Ä–µ–∑ TextureLoader: ${texturePath}`);
                }
                
                // –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å —á–µ—Ä–µ–∑ TextureLoader
                textureLoader.load(
                    texturePath,
                    (texture) => {
                        
                        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                        texture.flipY = false;
                        texture.generateMipmaps = false; // –û—Ç–∫–ª—é—á–∞–µ–º –º–∏–ø–º–∞–ø—ã –¥–ª—è PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
                        texture.minFilter = THREE.LinearFilter; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–∏–Ω–µ–π–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –±–µ–∑ –º–∏–ø–º–∞–ø–æ–≤
                        texture.magFilter = THREE.LinearFilter;
                        texture.anisotropy = anisotropy;
                        // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                        texture.offset.set(1, 0);
                        texture.repeat.set(-1, 1);
                        texture.center.set(0.5, 0.5);
                        resolve(texture);
                    },
                    undefined,
                    (error) => {
                        
                        // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å, –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ Image –∏ Canvas
                        const img = new Image();
                        
                        // –î–ª—è file:// –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º crossOrigin, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å CORS –æ—à–∏–±–æ–∫
                        const isFileProtocolLocal = window.location.protocol === 'file:';
                        if (!isFileProtocolLocal) {
                            img.crossOrigin = 'anonymous';
                        }
                        
                        img.onload = function() {
                            
                            // –î–ª—è file:// –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º Image –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ Texture
                            // —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å "tainted canvas"
                            if (isFileProtocolLocal) {
                                // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                                const texture = new THREE.Texture(img);
                                texture.wrapS = THREE.ClampToEdgeWrapping;
                                texture.wrapT = THREE.ClampToEdgeWrapping;
                                texture.flipY = false;
                                texture.needsUpdate = true;
                                texture.generateMipmaps = false; // –û—Ç–∫–ª—é—á–∞–µ–º –º–∏–ø–º–∞–ø—ã –¥–ª—è PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
                                texture.minFilter = THREE.LinearFilter; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–∏–Ω–µ–π–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –±–µ–∑ –º–∏–ø–º–∞–ø–æ–≤
                                texture.magFilter = THREE.LinearFilter;
                                texture.anisotropy = anisotropy;
                                // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                                texture.offset.set(1, 0);
                                texture.repeat.set(-1, 1);
                                texture.center.set(0.5, 0.5);
                                resolve(texture);
                            } else {
                                // –î–ª—è HTTP –∏—Å–ø–æ–ª—å–∑—É–µ–º Canvas (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω—É–∂–Ω–æ –¥–ª—è CORS)
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                
                                const texture = new THREE.CanvasTexture(canvas);
                                texture.wrapS = THREE.ClampToEdgeWrapping;
                                texture.wrapT = THREE.ClampToEdgeWrapping;
                                texture.flipY = false;
                                texture.generateMipmaps = false; // –û—Ç–∫–ª—é—á–∞–µ–º –º–∏–ø–º–∞–ø—ã –¥–ª—è PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
                                texture.minFilter = THREE.LinearFilter; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–∏–Ω–µ–π–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –±–µ–∑ –º–∏–ø–º–∞–ø–æ–≤
                                texture.magFilter = THREE.LinearFilter;
                                texture.anisotropy = anisotropy;
                                // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                                texture.offset.set(1, 0);
                                texture.repeat.set(-1, 1);
                                texture.center.set(0.5, 0.5);
                                resolve(texture);
                            }
                        };
                        
                        img.onerror = function() {
                            
                            // –°–æ–∑–¥–∞–µ–º –∑–∞–≥–ª—É—à–∫—É
                            resolve(createPlaceholderTexture(filename));
                        };
                        
                        // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –ø—É—Ç–∏, –≤–∫–ª—é—á–∞—è GitHub raw URLs –∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
                        const basePath = window.location.pathname.replace(/\/[^/]*$/, '');
                        const origin = window.location.origin;
                        const pathParts = window.location.pathname.split('/').filter(p => p);
                        
                        // –§–æ—Ä–º–∏—Ä—É–µ–º –ø—É—Ç–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
                        const paths = [];
                        
                        if (isFileProtocolLocal) {
                            // –î–ª—è file:// –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –ø—Ä–æ–±—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏
                            const currentDir = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                            paths.push(
                                filename, // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å
                                `./${filename}`, // –¢–µ–∫—É—â–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
                                `${currentDir}${filename}`, // –ü–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
                                `${basePath}/${filename}`, // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ basePath
                                `${origin}${basePath}/${filename}` // –° –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–º file://
                            );
                            console.log(`[file://] –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å ${filename} –∏–∑ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: ${currentDir}`);
                        } else {
                            // –î–ª—è HTTP/HTTPS –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤
                            paths.push(
                                filename, // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å
                                `./${filename}`, // –¢–µ–∫—É—â–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
                                `${basePath}/${filename}`, // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ basePath
                                `${origin}${basePath}/${filename}` // –ü–æ–ª–Ω—ã–π –ø—É—Ç—å –¥–ª—è GitHub Pages
                            );
                        }
                        
                        // –ï—Å–ª–∏ —ç—Ç–æ GitHub Pages, –¥–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ raw content
                        if (origin.includes('github.io') && pathParts.length >= 2) {
                            const user = pathParts[0];
                            const repo = pathParts[1];
                            // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–µ—Ç–∫–∏ GitHub
                            paths.push(`https://raw.githubusercontent.com/${user}/${repo}/main/${filename}`);
                            paths.push(`https://raw.githubusercontent.com/${user}/${repo}/master/${filename}`);
                            paths.push(`https://raw.githubusercontent.com/${user}/${repo}/gh-pages/${filename}`);
                            // –¢–∞–∫–∂–µ –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ GitHub Pages –Ω–∞–ø—Ä—è–º—É—é
                            paths.push(`https://${user}.github.io/${repo}/${filename}`);
                        }
                        
                        // –ï—Å–ª–∏ —ç—Ç–æ –æ–±—ã—á–Ω—ã–π GitHub —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π (–Ω–µ Pages), –ø—Ä–æ–±—É–µ–º raw content
                        if (origin.includes('github.com') && !origin.includes('github.io')) {
                            const urlParts = window.location.href.split('/');
                            const userIndex = urlParts.findIndex(p => p.includes('github.com')) + 1;
                            if (userIndex > 0 && urlParts[userIndex + 1]) {
                                const user = urlParts[userIndex];
                                const repo = urlParts[userIndex + 1];
                                paths.push(`https://raw.githubusercontent.com/${user}/${repo}/main/${filename}`);
                                paths.push(`https://raw.githubusercontent.com/${user}/${repo}/master/${filename}`);
                            }
                        }
                        
                        
                        let pathIndex = 0;
                        const tryNextPath = () => {
                            if (pathIndex < paths.length) {
                                const currentPath = paths[pathIndex++];
                                console.log(`[${isFileProtocolLocal ? 'file://' : 'http'}] –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å ${filename} –ø–æ –ø—É—Ç–∏: ${currentPath}`);
                                img.src = currentPath;
                            } else {
                                console.error(`[${isFileProtocolLocal ? 'file://' : 'http'}] –í—Å–µ –ø—É—Ç–∏ –¥–ª—è ${filename} –∏—Å—á–µ—Ä–ø–∞–Ω—ã, —Å–æ–∑–¥–∞–µ–º –∑–∞–≥–ª—É—à–∫—É`);
                                img.onerror();
                            }
                        };
                        
                        const originalError = img.onerror;
                        img.onerror = function() {
                            if (pathIndex < paths.length) {
                                tryNextPath();
                            } else {
                                originalError.call(this);
                            }
                        };
                        
                        tryNextPath();
                    }
                );
            });
        }
        
        // –°–æ–∑–¥–∞–µ–º –¥–æ–¥–µ–∫–∞—ç–¥—Ä —Å –æ–¥–Ω–∏–º –º–∞—Ç–µ—Ä–∏–∞–ª–æ–º –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        const testMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00, // –Ø—Ä–∫–∏–π –∑–µ–ª–µ–Ω—ã–π –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
            side: THREE.DoubleSide,
            transparent: false,
            opacity: 1.0
        });
        
        const dodecahedron = new THREE.Mesh(geometry, testMaterial);
        dodecahedron.position.set(0, 0, 0);
        dodecahedron.scale.set(3, 3, 3);
        dodecahedron.visible = false; // –°–∫—Ä—ã–≤–∞–µ–º –¥–æ –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö —Ç–µ–∫—Å—Ç—É—Ä
        scene.add(dodecahedron);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ç—Ä–∏—Ü—É –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ scale
        dodecahedron.updateMatrix();
        dodecahedron.updateMatrixWorld();
        
        // –°–æ–∑–¥–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏ (–¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏)
        const basicMaterials = [];
        for (let i = 0; i < 12; i++) {
            basicMaterials.push(new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0
            }));
        }
        
        // –¢–µ—Å—Ç–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã —É–¥–∞–ª–µ–Ω—ã - –¥–æ–¥–µ–∫–∞—ç–¥—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä scale –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏:', dodecahedron.scale);
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä —Å–æ–∑–¥–∞–Ω —Å –∑–µ–ª–µ–Ω—ã–º –º–∞—Ç–µ—Ä–∏–∞–ª–æ–º –¥–ª—è —Ç–µ—Å—Ç–∞');
        console.log('–í—Å–µ–≥–æ –æ–±—ä–µ–∫—Ç–æ–≤ –≤ —Å—Ü–µ–Ω–µ:', scene.children.length);
        
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –¥–æ–¥–µ–∫–∞—ç–¥—Ä –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        window.dodecahedron = dodecahedron;
        window.dodecahedronMaterials = basicMaterials; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        window.dodecahedronGeometry = geometry;
        
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä —Å–æ–∑–¥–∞–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ü–µ–Ω—É');
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä –≤ —Å—Ü–µ–Ω–µ:', scene.children.includes(dodecahedron));
        console.log('–ü–æ–∑–∏—Ü–∏—è –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞:', dodecahedron.position);
        console.log('–ü–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã:', camera.position);
        console.log('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ç–µ–π –≤ —Å—Ü–µ–Ω–µ:', scene.children.length);
        console.log('–ú–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞:', dodecahedron.material);
        
        // –î–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
        console.log('=== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –í–ò–î–ò–ú–û–°–¢–ò ===');
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä visible:', dodecahedron.visible);
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä scale:', dodecahedron.scale);
        const currentMaterial = Array.isArray(dodecahedron.material) ? dodecahedron.material[0] : dodecahedron.material;
        console.log('–¢–∏–ø –º–∞—Ç–µ—Ä–∏–∞–ª–∞:', currentMaterial?.type);
        console.log('–¶–≤–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–∞:', currentMaterial?.color?.getHex());
        console.log('–ú–∞—Ç–µ—Ä–∏–∞–ª visible:', currentMaterial?.visible);
        console.log('–ú–∞—Ç–µ—Ä–∏–∞–ª transparent:', currentMaterial?.transparent);
        console.log('–ú–∞—Ç–µ—Ä–∏–∞–ª opacity:', currentMaterial?.opacity);
        const verticesCount = geometry.attributes?.position ? geometry.attributes.position.count / 3 : (geometry.vertices?.length || 0);
        const facesCount = geometry.index ? geometry.index.count / 3 : (geometry.faces?.length || verticesCount / 3);
        console.log('–ì–µ–æ–º–µ—Ç—Ä–∏—è vertices:', verticesCount);
        console.log('–ì–µ–æ–º–µ—Ç—Ä–∏—è faces:', facesCount);
        console.log('–¢–∏–ø –≥–µ–æ–º–µ—Ç—Ä–∏–∏:', geometry.type);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≤ frustum
        const frustum = new THREE.Frustum();
        camera.updateMatrixWorld();
        const matrix = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        frustum.setFromProjectionMatrix(matrix);
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä –≤ frustum –∫–∞–º–µ—Ä—ã:', frustum.intersectsObject(dodecahedron));
        
        // Bounding box
        const bbox = new THREE.Box3().setFromObject(dodecahedron);
        const bboxCenter = bbox.getCenter(new THREE.Vector3());
        const bboxSize = bbox.getSize(new THREE.Vector3());
        console.log('Bounding box min:', bbox.min.x, bbox.min.y, bbox.min.z);
        console.log('Bounding box max:', bbox.max.x, bbox.max.y, bbox.max.z);
        console.log('Bounding box center:', bboxCenter.x, bboxCenter.y, bboxCenter.z);
        console.log('Bounding box size:', bboxSize.x, bboxSize.y, bboxSize.z);
        console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –∫–∞–º–µ—Ä—ã –¥–æ —Ü–µ–Ω—Ç—Ä–∞:', camera.position.distanceTo(bboxCenter));
        console.log('–ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞:', camera.getWorldDirection(new THREE.Vector3()));
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
        const vector = new THREE.Vector3();
        dodecahedron.getWorldPosition(vector);
        vector.project(camera);
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö:', 
            (vector.x * 0.5 + 0.5) * window.innerWidth, 
            (vector.y * -0.5 + 0.5) * window.innerHeight);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª - –¥–ª—è file:// –Ω—É–∂–µ–Ω –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä
        const isFileProtocol = window.location.protocol === 'file:';
        if (isFileProtocol) {
            console.warn('‚ö†Ô∏è –§–∞–π–ª –æ—Ç–∫—Ä—ã—Ç —á–µ—Ä–µ–∑ file:// –ø—Ä–æ—Ç–æ–∫–æ–ª. –î–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ª–æ–∫–∞–ª—å–Ω—ã–π HTTP —Å–µ—Ä–≤–µ—Ä:');
            console.warn('   Python: python -m http.server 8000');
            console.warn('   Node.js: npx http-server');
            console.warn('   –ó–∞—Ç–µ–º –æ—Ç–∫—Ä–æ–π—Ç–µ http://localhost:8000');
        }
        
        // –≠–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
        const loadingOverlay = document.getElementById('loading-overlay');
        const progressBar = document.getElementById('progress-bar');
        const progressPercent = document.getElementById('progress-percent');
        const hexProgress = document.getElementById('hex-progress');
        let hexProgressLen = null;
        if (hexProgress && typeof hexProgress.getTotalLength === 'function') {
            try {
                hexProgressLen = hexProgress.getTotalLength();
                hexProgress.style.strokeDasharray = String(hexProgressLen);
                hexProgress.style.strokeDashoffset = String(hexProgressLen);
            } catch (e) {
                hexProgressLen = null;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        function updateProgress(loaded, total) {
            const percent = Math.round((loaded / total) * 100);
            if (progressBar) progressBar.style.width = percent + '%';
            progressPercent.textContent = percent + '%';
            if (hexProgress && hexProgressLen) {
                const t = Math.max(0, Math.min(1, percent / 100));
                hexProgress.style.strokeDashoffset = String(hexProgressLen * (1 - t));
            }
        }
        
        // –û–±—ä—è–≤–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–π –≥—Ä–∞–Ω–µ–π (–±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –≥—Ä–∞–Ω–µ–π)
        // –î–µ–ª–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–º –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–π —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏
        window.faceOrientations = [];
        const faceOrientations = window.faceOrientations;
        for (let i = 0; i < 12; i++) {
            faceOrientations.push({ rotation: 0, flipX: false, flipY: false });
        }
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –≤—Å–µ—Ö 12 –≥—Ä–∞–Ω–µ–π
        const textures = [];
        const texturePromises = [];
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä –¥–æ –∑–∞–≥—Ä—É–∑–∫–∏
        if (!window.textureSettings) {
            window.textureSettings = {};
        }
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö –≥—Ä–∞–Ω–µ–π
        window.textureSettings[0] = { rotation: -1.570796, offsetX: -0.960000, offsetY: 0.080000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 1
        window.textureSettings[1] = { rotation: -1.535890, offsetX: -0.990000, offsetY: 0.000000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 2
        window.textureSettings[2] = { rotation: -1.518436, offsetX: -1.060000, offsetY: 0.030000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 3
        window.textureSettings[3] = { rotation: -1.535890, offsetX: -0.960000, offsetY: 0.020000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 4
        window.textureSettings[4] = { rotation: -0.296706, offsetX: -1.030000, offsetY: 0.080000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 5
        window.textureSettings[5] = { rotation: -0.279253, offsetX: -1.030000, offsetY: 0.090000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 6
        window.textureSettings[6] = { rotation: -1.535890, offsetX: -1.000000, offsetY: 0.000000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 7
        window.textureSettings[7] = { rotation: -1.535890, offsetX: -1.040000, offsetY: 0.020000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 8
        window.textureSettings[8] = { rotation: -1.535890, offsetX: -1.000000, offsetY: 0.000000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 9
        window.textureSettings[9] = { rotation: -1.535890, offsetX: -0.950000, offsetY: 0.030000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 10
        window.textureSettings[10] = { rotation: -2.827433, offsetX: -0.950000, offsetY: 0.100000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 11
        window.textureSettings[11] = { rotation: -1.535890, offsetX: -0.990000, offsetY: -0.010000, scale: 1.000000 }; // –ì—Ä–∞–Ω—å 12
        
        let loadedCount = 0;
        const totalTextures = 12;
        
        for (let i = 1; i <= 12; i++) {
            const filename = `${String(i).padStart(3, '0')}.png`;
            texturePromises.push(
                loadImageAsTexture(filename).then(texture => {
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –∑–∞–≥–ª—É—à–∫–æ–π
                    const isPlaceholder = texture.image && texture.image.width === 512 && texture.image.height === 512;
                    if (isPlaceholder) {
                        console.warn(`‚ö† –¢–µ–∫—Å—Ç—É—Ä–∞ ${filename} –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–∞–≥–ª—É—à–∫–∞`);
                    }
                    
                    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—è—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫–∞
                    // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ 2000x2000, –ø—è—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫ —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.flipY = false; // –í–∞–∂–Ω–æ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
                    texture.generateMipmaps = false; // –û—Ç–∫–ª—é—á–∞–µ–º –º–∏–ø–º–∞–ø—ã –¥–ª—è PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
                    texture.minFilter = THREE.LinearFilter; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–∏–Ω–µ–π–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –±–µ–∑ –º–∏–ø–º–∞–ø–æ–≤
                    texture.magFilter = THREE.LinearFilter;
                    
                    // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                    texture.offset.set(1, 0);
                    texture.repeat.set(-1, 1);
                    texture.center.set(0.5, 0.5);
                    
                    // –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –¥–ª—è PNG —Å –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª–æ–º
                    if (texture.image && texture.image.complete) {
                        // –¢–µ–∫—Å—Ç—É—Ä–∞ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞
                    }
                    
                    textures[i - 1] = texture;
                    loadedCount++;
                    updateProgress(loadedCount, totalTextures);
                    console.log(`‚úì –¢–µ–∫—Å—Ç—É—Ä–∞ ${filename} –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ (${loadedCount}/${totalTextures})${isPlaceholder ? ' [–ó–ê–ì–õ–£–®–ö–ê]' : ''} - —Ä–∞–∑–º–µ—Ä: ${texture.image?.width}x${texture.image?.height}`);
                    return texture;
                }).catch(err => {
                    
                    console.warn(`‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å ${filename}, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–≥–ª—É—à–∫—É:`, err);
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É –∫–∞–∫ –∑–∞–≥–ª—É—à–∫—É
                    const placeholder = createNumberedTexture(i);
                    textures[i - 1] = placeholder;
                    loadedCount++;
                    updateProgress(loadedCount, totalTextures);
                    return placeholder;
                })
            );
        }
        
        // –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö —Ç–µ–∫—Å—Ç—É—Ä
        Promise.all(texturePromises).then(() => {
            console.log('–í—Å–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã:', textures.length);
            
            // –°–æ–∑–¥–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã —Å —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏
            // –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É 2000x2000 —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–µ–π –∏–∑ faceOrientations
            const newMaterials = [];
            for (let i = 0; i < 12; i++) {
                const texture = textures[i];
                const orientation = faceOrientations[i] || { rotation: 0, flipX: false, flipY: false };
                
                // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä –ø—Ä–∏–º–µ–Ω–µ–Ω—ã (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –æ–Ω–∏ –±—ã–ª–∏ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã)
                if (texture) {
                    texture.generateMipmaps = false;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    // –£–ª—É—á—à–∞–µ—Ç —á–µ—Ç–∫–æ—Å—Ç—å –ø–æ–¥ —É–≥–ª–æ–º (–æ—Å–æ–±–µ–Ω–Ω–æ —Ç–µ–∫—Å—Ç) ‚Äî –ø–æ—á—Ç–∏ –±–µ—Å–ø–ª–∞—Ç–Ω–æ –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–µ
                    if (renderer.capabilities && renderer.capabilities.getMaxAnisotropy) {
                        texture.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy() || 1);
                    }
                    texture.needsUpdate = true;
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É —Å –∑–µ—Ä–∫–∞–ª—å–Ω—ã–º –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ–º
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
                    texture.offset.set(0, 0);
                    texture.repeat.set(1, 1);
                    texture.center.set(0.5, 0.5);
                    texture.rotation = 0;
                    
                    // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                    texture.offset.x = 1;
                    texture.repeat.x = -1;
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä—É—á–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–∫—Å—Ç—É—Ä—ã (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
                    // –≠—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω—è—Ç—å —á–µ—Ä–µ–∑ –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    const textureSettings = window.textureSettings || {};
                    const faceSettings = textureSettings[i] || { rotation: 0, offsetX: 0, offsetY: 0, scale: 1.0 };
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–± (—á–µ—Ä–µ–∑ repeat)
                    const scale = faceSettings.scale || 1.0;
                    texture.repeat.set(-1 / scale, 1 / scale);
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç (–±–∞–∑–æ–≤—ã–π + —Ä—É—á–Ω–æ–π)
                    texture.rotation = (orientation.rotation || 0) + faceSettings.rotation;
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
                    texture.offset.x = 1 + faceSettings.offsetX;
                    texture.offset.y = faceSettings.offsetY;
                    
                    // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Ç–µ–∫—Å—Ç—É—Ä–∞ –æ–±–Ω–æ–≤–∏—Ç—Å—è
                    texture.needsUpdate = true;
                    
                }
                
                // –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –¥–ª—è PNG —Å –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª–æ–º
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º MeshStandardMaterial –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –æ—Å–≤–µ—â–µ–Ω–∏—è –∏ –∫—Ä–∞—Å–∏–≤—ã—Ö —Å–≤–µ—Ç–æ—Ç–µ–Ω–µ–π
                newMaterials.push(new THREE.MeshStandardMaterial({
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true, // –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –¥–ª—è PNG
                    opacity: 1.0,
                    alphaTest: 0.0, // –ù–∏–∑–∫–∏–π –ø–æ—Ä–æ–≥ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
                    metalness: 0.05, // –õ–µ–≥–∫–∏–π –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–π –æ—Ç–±–ª–µ—Å–∫
                    roughness: 0.85, // –ú–∞—Ç–æ–≤–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –¥–ª—è –º—è–≥–∫–∏—Ö —Ç–µ–Ω–µ–π
                    emissive: 0x000000, // –ë–µ–∑ —Å–≤–µ—á–µ–Ω–∏—è
                    emissiveIntensity: 0.0
                }));
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
            if (window.dodecahedron) {
                window.dodecahedron.material = newMaterials;
                window.dodecahedronMaterials = newMaterials;
                console.log('–†–µ–∞–ª—å–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ –¥–æ–¥–µ–∫–∞—ç–¥—Ä—É');
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–µ–ª—å –∏ —Å–∫—Ä—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
                window.dodecahedron.visible = true;
                setTimeout(() => {
                    loadingOverlay.classList.add('hidden');
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 500);
                }, 300);
            }
        });
        
        // –í—Ä–µ–º–µ–Ω–Ω–æ —Å–æ–∑–¥–∞–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã —Å –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ –∑–∞–≥—Ä—É–∑–∫–∏
        const newMaterials = [];
        for (let i = 0; i < 12; i++) {
            const tempTexture = createNumberedTexture(i + 1);
            tempTexture.offset.set(0, 0);
            tempTexture.repeat.set(1, 1);
            tempTexture.center.set(0.5, 0.5);
            
            newMaterials.push(new THREE.MeshStandardMaterial({
                map: tempTexture,
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0,
                metalness: 0.1,
                roughness: 0.7
            }));
        }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≥–µ–æ–º–µ—Ç—Ä–∏–∏
            // DodecahedronGeometry: 12 –≥—Ä–∞–Ω–µ–π, –∫–∞–∂–¥–∞—è –≥—Ä–∞–Ω—å - –ø–µ–Ω—Ç–∞–≥–æ–Ω (5 –≤–µ—Ä—à–∏–Ω = 3 —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ = 9 –∏–Ω–¥–µ–∫—Å–æ–≤)
            const hasIndex = geometry.index !== null && geometry.index !== undefined;
            const totalIndices = hasIndex ? geometry.index.count : 108; // 12 –≥—Ä–∞–Ω–µ–π * 9 –∏–Ω–¥–µ–∫—Å–æ–≤ = 108
            const totalFaces = totalIndices / 3; // 36 —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
            const facesPerGroup = 3; // 3 —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –Ω–∞ –≥—Ä–∞–Ω—å (–ø–µ–Ω—Ç–∞–≥–æ–Ω)
            const indicesPerGroup = 9; // 3 —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ * 3 –∏–Ω–¥–µ–∫—Å–∞ = 9
            
            console.log('=== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ì–ï–û–ú–ï–¢–†–ò–ò ===');
            console.log('geometry.index —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:', hasIndex);
            console.log('–í—Å–µ–≥–æ –∏–Ω–¥–µ–∫—Å–æ–≤:', totalIndices);
            console.log('–í—Å–µ–≥–æ –≥—Ä–∞–Ω–µ–π (—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤):', totalFaces);
            console.log('–ì—Ä–∞–Ω–µ–π –Ω–∞ –≥—Ä—É–ø–ø—É:', facesPerGroup);
            console.log('–ò–Ω–¥–µ–∫—Å–æ–≤ –Ω–∞ –≥—Ä—É–ø–ø—É:', indicesPerGroup);
            console.log('–°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ groups:', geometry.groups?.length || 0);
            if (geometry.groups && geometry.groups.length > 0) {
                console.log('–ü–µ—Ä–≤—ã–µ 3 groups:', geometry.groups.slice(0, 3));
            }
            
            
            // –ï—Å–ª–∏ –∏–Ω–¥–µ–∫—Å–Ω—ã–π –º–∞—Å—Å–∏–≤ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞–µ–º –µ–≥–æ
            // –í –Ω–µ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∫–∞–∂–¥–∞—è –≤–µ—Ä—à–∏–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
            // –ü–æ—ç—Ç–æ–º—É –∏–Ω–¥–µ–∫—Å–Ω—ã–π –º–∞—Å—Å–∏–≤ –±—É–¥–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–º: [0, 1, 2, 3, ...]
            if (!hasIndex) {
                console.log('–°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å–Ω—ã–π –º–∞—Å—Å–∏–≤ –¥–ª—è –≥–µ–æ–º–µ—Ç—Ä–∏–∏...');
                const positions = geometry.attributes.position;
                const vertexCount = positions.count;
                const indexArray = new Uint16Array(vertexCount);
                for (let i = 0; i < vertexCount; i++) {
                    indexArray[i] = i;
                }
                geometry.setIndex(new THREE.BufferAttribute(indexArray, 1));
                console.log('–ò–Ω–¥–µ–∫—Å–Ω—ã–π –º–∞—Å—Å–∏–≤ —Å–æ–∑–¥–∞–Ω:', vertexCount, '–∏–Ω–¥–µ–∫—Å–æ–≤');
                
            }
            
            // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º groups –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏
            // –í—Å–µ–≥–¥–∞ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º groups –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞
            geometry.groups = [];
            for (let i = 0; i < 12; i++) {
                geometry.groups.push({
                    start: i * indicesPerGroup,
                    count: indicesPerGroup,
                    materialIndex: i
                });
            }
            console.log('Groups —Å–æ–∑–¥–∞–Ω—ã/–æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞:', geometry.groups.length, '–≥—Ä—É–ø–ø');
            console.log('–ü–µ—Ä–≤—ã–µ 3 groups:', geometry.groups.slice(0, 3).map(g => ({start: g.start, count: g.count, materialIndex: g.materialIndex})));
            
            
            // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º UV-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä –Ω–∞ –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏
            const positions = geometry.attributes.position;
            // –í Three.js r128 index –º–æ–∂–µ—Ç –±—ã—Ç—å null, –Ω–æ –≥–µ–æ–º–µ—Ç—Ä–∏—è –≤—Å–µ —Ä–∞–≤–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ index –±–æ–ª–µ–µ —Ç—â–∞—Ç–µ–ª—å–Ω–æ
            const indices = geometry.index;
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–Ω—ã–º–∏ —Å–ø–æ—Å–æ–±–∞–º–∏
            const hasIndexForUV = indices !== null && indices !== undefined && (indices.count !== undefined ? indices.count > 0 : false);
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –º–æ–∂–µ—Ç –±—ã—Ç—å index –µ—Å—Ç—å, –Ω–æ count —Ä–∞–≤–µ–Ω 0 –∏–ª–∏ undefined
            console.log('–î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ geometry.index:');
            console.log('  geometry.index:', indices);
            console.log('  typeof geometry.index:', typeof indices);
            console.log('  geometry.index !== null:', indices !== null);
            console.log('  geometry.index !== undefined:', indices !== undefined);
            if (indices) {
                console.log('  indices.count:', indices.count);
                console.log('  indices.isBufferAttribute:', indices instanceof THREE.BufferAttribute);
            }
            
            console.log('=== –ü–ï–†–ï–°–ß–ï–¢ UV-–ö–û–û–†–î–ò–ù–ê–¢ ===');
            console.log('positions —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:', !!positions);
            console.log('indices —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:', hasIndexForUV);
            if (positions) console.log('positions.count:', positions.count);
            if (hasIndexForUV) console.log('indices.count:', indices.count);
            console.log('geometry.index:', geometry.index);
            console.log('geometry.attributes.uv —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:', !!geometry.attributes.uv);
            
            
            if (!positions) {
                console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ø–µ—Ä–µ—Å—á–µ—Ç–∞ UV');
            } else if (!hasIndexForUV) {
                // –ï—Å–ª–∏ –∏–Ω–¥–µ–∫—Å–æ–≤ –Ω–µ—Ç, –Ω–æ –µ—Å—Ç—å UV, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –∏—Ö –Ω–∞ –æ—Å–Ω–æ–≤–µ positions –∏ groups
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥: –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –Ω–∞—Ö–æ–¥–∏–º –≤–µ—Ä—à–∏–Ω—ã –ø–æ –±–ª–∏–∑–æ—Å—Ç–∏
                console.log('–ò–Ω–¥–µ–∫—Å—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç, –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º UV –Ω–∞ –æ—Å–Ω–æ–≤–µ positions –∏ groups');
                
                let uv = geometry.attributes.uv;
                if (!uv) {
                    uv = new THREE.BufferAttribute(new Float32Array(positions.count * 2), 2);
                    geometry.setAttribute('uv', uv);
                    console.log('UV-–∞—Ç—Ä–∏–±—É—Ç —Å–æ–∑–¥–∞–Ω');
                }
                
                // –î–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –Ω–∞—Ö–æ–¥–∏–º –≤–µ—Ä—à–∏–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç—å —ç—Ç–æ–π –≥—Ä–∞–Ω–∏
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥: –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –≤–µ—Ä—à–∏–Ω—ã –ø–æ –±–ª–∏–∑–æ—Å—Ç–∏ –∫ —Ü–µ–Ω—Ç—Ä—É –≥—Ä—É–ø–ø—ã
                for (let groupIndex = 0; groupIndex < geometry.groups.length; groupIndex++) {
                    const group = geometry.groups[groupIndex];
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–∏–º–µ—Ä–Ω—ã–π —Ü–µ–Ω—Ç—Ä –≥—Ä—É–ø–ø—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ start –ø–æ–∑–∏—Ü–∏–∏
                    // –í DodecahedronGeometry –∫–∞–∂–¥–∞—è –≥—Ä–∞–Ω—å –∏–º–µ–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ 5 –≤–µ—Ä—à–∏–Ω
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥: –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –Ω–∞—Ö–æ–¥–∏–º –≤–µ—Ä—à–∏–Ω—ã –ø–æ –±–ª–∏–∑–æ—Å—Ç–∏
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä –≥—Ä—É–ø–ø—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–∏–º–µ—Ä–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π –≤–µ—Ä—à–∏–Ω
                    // –ö–∞–∂–¥–∞—è –≥—Ä—É–ø–ø–∞ –∏–º–µ–µ—Ç start –∏ count, –Ω–æ –±–µ–∑ –∏–Ω–¥–µ–∫—Å–æ–≤ —Å–ª–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤–µ—Ä—à–∏–Ω—ã
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥: –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ UV
                    // –¥–ª—è –≤–µ—Ä—à–∏–Ω, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç—å —ç—Ç–æ–π –≥—Ä–∞–Ω–∏
                    
                    // –ü—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Ö–æ–¥: –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º UV –≤ —Ü–µ–Ω—Ç—Ä (0.5, 0.5)
                    // –¥–ª—è –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–≤—è–∑–∞–Ω—ã —Å —ç—Ç–æ–π –≥—Ä—É–ø–ø–æ–π
                    // –ù–æ —ç—Ç–æ –Ω–µ –∏–¥–µ–∞–ª—å–Ω–æ, –ø–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π –º–µ—Ç–æ–¥
                    
                    // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ UV, –Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏—Ö –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
                    // –î–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –Ω–∞—Ö–æ–¥–∏–º –≤–µ—Ä—à–∏–Ω—ã –ø–æ –±–ª–∏–∑–æ—Å—Ç–∏ –∫ —Ü–µ–Ω—Ç—Ä—É –≥—Ä—É–ø–ø—ã
                }
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ UV –∏–∑ –≥–µ–æ–º–µ—Ç—Ä–∏–∏, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
                // –ï—Å–ª–∏ –∏—Ö –Ω–µ—Ç, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ UV –≤ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
                if (geometry.attributes.uv && geometry.attributes.uv.count === positions.count) {
                    console.log('–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ UV-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –≥–µ–æ–º–µ—Ç—Ä–∏–∏');
                    // UV —É–∂–µ –µ—Å—Ç—å, –Ω–µ —Ç—Ä–æ–≥–∞–µ–º –∏—Ö
                } else {
                    // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ UV –≤ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
                    for (let i = 0; i < positions.count; i++) {
                        uv.setXY(i, 0.5, 0.5);
                    }
                    uv.needsUpdate = true;
                    console.log('UV-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ —Ü–µ–Ω—Ç—Ä –¥–ª—è –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥)');
                }
            } else {
                // –ù–û–í–´–ô –ü–†–û–°–¢–û–ô –ü–û–î–•–û–î: –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ UV –∏–∑ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—ã–µ UV [0,1]
                // –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏, —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç—É—Ä–∞ –ø–æ–∫—Ä—ã–≤–∞–ª–∞ –≤—Å—é –≥—Ä–∞–Ω—å
                
                let uv = geometry.attributes.uv;
                
                if (!uv) {
                    const uvCount = positions.count;
                    uv = new THREE.BufferAttribute(new Float32Array(uvCount * 2), 2);
                    geometry.setAttribute('uv', uv);
                    console.log('UV-–∞—Ç—Ä–∏–±—É—Ç —Å–æ–∑–¥–∞–Ω');
                }
                
                // –î–ª—è –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Å—Ç—ã–µ UV-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã [0,1]
                // —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç—É—Ä–∞ –ø–æ–∫—Ä—ã–≤–∞–ª–∞ –≤—Å—é –≥—Ä–∞–Ω—å
                for (let groupIndex = 0; groupIndex < geometry.groups.length; groupIndex++) {
                    const group = geometry.groups[groupIndex];
                    
                    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã –≤–µ—Ä—à–∏–Ω –¥–ª—è —ç—Ç–æ–π –≥—Ä–∞–Ω–∏
                    const vertexSet = new Set();
                    
                    for (let i = 0; i < group.count; i++) {
                        const indexPos = group.start + i;
                        if (indexPos < indices.count) {
                            const vertexIndex = indices.getX(indexPos);
                                vertexSet.add(vertexIndex);
                        }
                    }
                    
                    // –ü–æ–ª—É—á–∞–µ–º –≤–µ—Ä—à–∏–Ω—ã –≥—Ä–∞–Ω–∏ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
                    const vertexIndices = Array.from(vertexSet);
                    if (vertexIndices.length < 3) continue;
                    
                    const vertices = vertexIndices.map(idx => new THREE.Vector3(
                        positions.getX(idx),
                        positions.getY(idx),
                        positions.getZ(idx)
                    ));
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ—Ä–º–∞–ª—å –∏ —Ü–µ–Ω—Ç—Ä –≥—Ä–∞–Ω–∏ –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
                    const v0 = vertices[0];
                    const v1 = vertices[1];
                    const v2 = vertices[2];
                    let normal = new THREE.Vector3()
                        .subVectors(v1, v0)
                        .cross(new THREE.Vector3().subVectors(v2, v0))
                        .normalize();
                    
                    const center = new THREE.Vector3();
                    vertices.forEach(v => center.add(v));
                    center.divideScalar(vertices.length);
                    
                    const toCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), center);
                    if (normal.dot(toCenter) > 0) {
                        normal.negate();
                    }
                    
                    // –£–õ–£–ß–®–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: –ù–∞—Ö–æ–¥–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é –ø—è—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫–∞
                    // –°–æ–∑–¥–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é —Å–∏—Å—Ç–µ–º—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞ –≥—Ä–∞–Ω–∏
                    const worldUp = new THREE.Vector3(0, 1, 0);
                    let right = new THREE.Vector3().crossVectors(worldUp, normal).normalize();
                    if (right.length() < 0.1) {
                        const worldRight = new THREE.Vector3(1, 0, 0);
                        right = new THREE.Vector3().crossVectors(worldRight, normal).normalize();
                    }
                    const forward = new THREE.Vector3().crossVectors(normal, right).normalize();
                    
                    // –ù–∞—Ö–æ–¥–∏–º –≤–µ—Ä—Ö–Ω—é—é –≤–µ—Ä—à–∏–Ω—É (—Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º Y –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
                    // –≠—Ç–æ –≤–µ—Ä—à–∏–Ω–∞, –∫–æ—Ç–æ—Ä–∞—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–≤–µ—Ä—Ö—É —Ç–µ–∫—Å—Ç—É—Ä—ã
                    let topVertexIndex = 0;
                    let maxY = vertices[0].y;
                    for (let i = 1; i < vertices.length; i++) {
                        if (vertices[i].y > maxY) {
                            maxY = vertices[i].y;
                            topVertexIndex = i;
                        }
                    }
                    
                    const topVertex = vertices[topVertexIndex];
                    const toTop = new THREE.Vector3().subVectors(topVertex, center).normalize();
                    
                    // –ü—Ä–æ–µ—Ü–∏—Ä—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –≤–µ—Ä—Ö–Ω–µ–π –≤–µ—Ä—à–∏–Ω–µ –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å –≥—Ä–∞–Ω–∏
                    const componentAlongNormal = toTop.dot(normal);
                    const toTopInPlane = new THREE.Vector3()
                        .subVectors(toTop, normal.clone().multiplyScalar(componentAlongNormal));
                    
                    if (toTopInPlane.length() < 0.0001) {
                        toTopInPlane.copy(forward);
                    } else {
                        toTopInPlane.normalize();
                    }
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ —Ç–µ–∫—Å—Ç—É—Ä—ã
                    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ "–≤–≤–µ—Ä—Ö" –≤ UV –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é -forward
                    // (—Ç–∞–∫ –∫–∞–∫ –≤ UV Y —Ä–∞—Å—Ç–µ—Ç –≤–Ω–∏–∑)
                    // –£–≥–æ–ª –º–µ–∂–¥—É toTopInPlane –∏ -forward –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏
                    const dotUp = toTopInPlane.dot(forward);
                    const dotRight = toTopInPlane.dot(right);
                    let faceRotation = Math.atan2(dotUp, dotRight);
                    
                    // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —É–≥–æ–ª: –≤ UV –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö Y —Ä–∞—Å—Ç–µ—Ç –≤–Ω–∏–∑,
                    // –ø–æ—ç—Ç–æ–º—É –Ω—É–∂–Ω–æ –ø–æ–≤–µ—Ä–Ω—É—Ç—å –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤, —á—Ç–æ–±—ã –≤–µ—Ä—Ö–Ω—è—è –≤–µ—Ä—à–∏–Ω–∞ –±—ã–ª–∞ –≤–≤–µ—Ä—Ö—É
                    faceRotation += Math.PI;
                    
                    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —É–≥–æ–ª –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-PI, PI]
                    while (faceRotation > Math.PI) faceRotation -= 2 * Math.PI;
                    while (faceRotation < -Math.PI) faceRotation += 2 * Math.PI;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É–≥–æ–ª –≤–∞–ª–∏–¥–µ–Ω
                    if (isNaN(faceRotation) || !isFinite(faceRotation)) {
                        faceRotation = 0;
                    }
                    
                    console.log(`–ì—Ä–∞–Ω—å ${groupIndex + 1}: —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ = ${(faceRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é
                    faceOrientations[groupIndex] = {
                        rotation: faceRotation,
                        flipX: false,
                        flipY: false
                    };
                    
                    // –ü–†–û–°–¢–û–ô –ü–û–î–•–û–î: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º UV [0,1] –¥–ª—è –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω –≥—Ä–∞–Ω–∏
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é –ø—Ä–æ–µ–∫—Ü–∏—é: –∫–∞–∂–¥–∞—è –≤–µ—Ä—à–∏–Ω–∞ –ø–æ–ª—É—á–∞–µ—Ç UV –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ—ë –ø–æ–∑–∏—Ü–∏–∏
                    // –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞ –≥—Ä–∞–Ω–∏ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                    let minU = Infinity, maxU = -Infinity;
                    let minV = Infinity, maxV = -Infinity;
                    const vertexUVMap = new Map();
                    
                    vertexIndices.forEach((vertexIndex, idx) => {
                        const vertex = vertices[idx];
                        const localPos = new THREE.Vector3().subVectors(vertex, center);
                        const u = localPos.dot(right);
                        const v = localPos.dot(forward);
                        vertexUVMap.set(vertexIndex, { u, v });
                        minU = Math.min(minU, u);
                        maxU = Math.max(maxU, u);
                        minV = Math.min(minV, v);
                        maxV = Math.max(maxV, v);
                    });
                    
                    const rangeU = maxU - minU || 1;
                    const rangeV = maxV - minV || 1;
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º UV –∫–æ –≤—Å–µ–º –∏–Ω–¥–µ–∫—Å–∞–º –≤ –≥—Ä—É–ø–ø–µ
                    for (let i = 0; i < group.count; i++) {
                        const indexPos = group.start + i;
                        if (indexPos < indices.count) {
                            const vertexIndex = indices.getX(indexPos);
                            const uvData = vertexUVMap.get(vertexIndex);
                            
                            if (uvData) {
                                // –ü—Ä–æ—Å—Ç–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫ [0, 1]
                                const normalizedU = rangeU > 0 ? (uvData.u - minU) / rangeU : 0.5;
                                const normalizedV = rangeV > 0 ? (uvData.v - minV) / rangeV : 0.5;
                                
                        uv.setXY(vertexIndex, normalizedU, normalizedV);
                            }
                        }
                    }
                }
                
                uv.needsUpdate = true;
                console.log('UV-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è –≤—Å–µ—Ö –≥—Ä–∞–Ω–µ–π (–ø—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Ö–æ–¥)');
                console.log('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –≥—Ä—É–ø–ø:', geometry.groups.length);
                
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
            window.dodecahedron.material = newMaterials;
            window.dodecahedronMaterials = newMaterials;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ materials –∏ groups –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–≤—è–∑–∞–Ω—ã
            console.log('=== –ü–†–û–í–ï–†–ö–ê –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø –ú–ê–¢–ï–†–ò–ê–õ–û–í ===');
            console.log('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤:', newMaterials.length);
            console.log('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ groups:', geometry.groups.length);
            console.log('Groups —Å materialIndex:');
            geometry.groups.forEach((group, i) => {
                console.log(`  Group ${i}: start=${group.start}, count=${group.count}, materialIndex=${group.materialIndex}`);
                if (group.materialIndex >= 0 && group.materialIndex < newMaterials.length) {
                    const material = newMaterials[group.materialIndex];
                    console.log(`    –ú–∞—Ç–µ—Ä–∏–∞–ª ${group.materialIndex}: type=${material.type}, hasTexture=${!!material.map}`);
                } else {
                    console.warn(`    –û–®–ò–ë–ö–ê: materialIndex ${group.materialIndex} –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [0, ${newMaterials.length - 1}]`);
                }
            });
            
            
            // #region agent log
            
        console.log('–ë–µ–ª—ã–µ –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø—Ä–∏–º–µ–Ω–µ–Ω—ã');
        console.log('=== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ü–û–°–õ–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø –¢–ï–ö–°–¢–£–† ===');
        console.log('–ù–æ–≤—ã–π —Ç–∏–ø –º–∞—Ç–µ—Ä–∏–∞–ª–∞:', newMaterials[0]?.type);
        console.log('–ú–∞—Ç–µ—Ä–∏–∞–ª –∏–º–µ–µ—Ç —Ç–µ–∫—Å—Ç—É—Ä—É:', !!newMaterials[0]?.map);
        console.log('–†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç—É—Ä—ã:', newMaterials[0]?.map ? `${newMaterials[0].map.image?.width}x${newMaterials[0].map.image?.height}` : '–Ω–µ—Ç');
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä visible:', window.dodecahedron.visible);
        console.log('–î–æ–¥–µ–∫–∞—ç–¥—Ä material:', window.dodecahedron.material);
        
        // –°–∏—Å—Ç–µ–º–∞ –≤—ã–±–æ—Ä–∞ –∏ –≤—Ä–∞—â–µ–Ω–∏—è –≥—Ä–∞–Ω–∏ - –æ–±—ä—è–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –î–û –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        let selectedFaceIndex = -1;
        let faceControlsPanel = document.getElementById('face-controls-panel');
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDraggingForRotation = false;
        let dragStartPosition = null;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –≤—ã–±–æ—Ä–∞ –≥—Ä–∞–Ω–∏ –∏ —Å–ø–∏—Å–∫–∞ –≥—Ä–∞–Ω–µ–π
        try {
            console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—ã–±–æ—Ä–∞ –≥—Ä–∞–Ω–µ–π –∏ —Å–ø–∏—Å–∫–∞');
            faceListElement = document.getElementById('face-list');
            if (!faceListElement) {
                console.error('–≠–ª–µ–º–µ–Ω—Ç #face-list –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ DOM');
            }
            initFaceSelection();
            initFaceList();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏
            initTextureControls();
            
            // #region agent log
        } catch (e) {
            console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤—ã–±–æ—Ä–∞ –≥—Ä–∞–Ω–µ–π:', e);
        }
        
        // –ù–∞—á–∞–ª—å–Ω–∞—è —Å—Ü–µ–Ω–∞: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≥—Ä–∞–Ω—å 12, –Ω–æ –æ—Å—Ç–∞—ë–º—Å—è –≤ —Ä–µ–∂–∏–º–µ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è (–≥–ª–æ–±—É—Å)
        setTimeout(() => {
            if (window.dodecahedron) {
                camera.position.set(0, 0, initialCameraZ);
                deselectFace(); // selectedFaceIndex = -1, –ø–∞–Ω–µ–ª—å —Å–∫—Ä—ã—Ç–∞
                centerOnFace(11, true); // –ì—Ä–∞–Ω—å 12 (–∏–Ω–¥–µ–∫—Å 11), —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º –∞–≤—Ç–æ-–ø–æ–≤–æ—Ä–æ—Ç–∞ + —Ç–æ–Ω–∫–æ–π –¥–æ–∫—Ä—É—Ç–∫–∏
            }
        }, 100); // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏, —á—Ç–æ –≤—Å–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ

        const DEBUG = !isMobile;
        const DEBUG_INTERACTION =
            new URLSearchParams(window.location.search).has('debug') ||
            window.localStorage.getItem('debugInteraction') === '1';
        
        const logState = () => {
            if (!window.dodecahedron) return {};
            const r = window.dodecahedron.rotation;
            const p = window.dodecahedron.position;
            const q = window.dodecahedron.quaternion;
            return {
                mode: selectedFaceIndex < 0 ? 'globe' : `face:${selectedFaceIndex + 1}`,
                rot: { x: +r.x.toFixed(4), y: +r.y.toFixed(4), z: +r.z.toFixed(4) },
                quat: { x: +q.x.toFixed(4), y: +q.y.toFixed(4), z: +q.z.toFixed(4), w: +q.w.toFixed(4) },
                pos: { x: +p.x.toFixed(4), y: +p.y.toFixed(4), z: +p.z.toFixed(4) },
                camZ: +camera.position.z.toFixed(3)
            };
        };
        
        // –ë—É—Ñ–µ—Ä –ª–æ–≥–æ–≤ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è (–¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–µ–ª–∏–∫–æ–º)
        const __interactionLogs = [];
        const __maxInteractionLogs = 2000;
        
        let __lastMoveLogAt = 0;
        function logInteraction(eventName, data = {}, throttleMs = 0) {
            if (!DEBUG_INTERACTION) return;
            const now = performance.now();
            if (throttleMs > 0 && now - __lastMoveLogAt < throttleMs) return;
            if (throttleMs > 0) __lastMoveLogAt = now;
            
            const entry = {
                t: Math.round(now),
                event: eventName,
                data: data,
                state: logState()
            };
            __interactionLogs.push(entry);
            if (__interactionLogs.length > __maxInteractionLogs) {
                __interactionLogs.splice(0, __interactionLogs.length - __maxInteractionLogs);
            }
            
            console.log(`[TRIZ][${entry.t}ms] ${eventName}`, { ...data, ...entry.state });
        }
        
        // API –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ª–æ–≥–æ–≤ (–≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞)
        window.TRIZDebug = {
            enabled: DEBUG_INTERACTION,
            getLogs: () => __interactionLogs.slice(),
            clearLogs: () => {
                __interactionLogs.length = 0;
                console.log('[TRIZ] logs cleared');
            },
            copyLogs: async (format = 'text') => {
                const logs = __interactionLogs.slice();
                if (!logs.length) {
                    console.log('[TRIZ] no logs to copy');
                    return;
                }
                
                let text = '';
                if (format === 'json') {
                    text = JSON.stringify(logs, null, 2);
                } else {
                    // text
                    text = logs.map(l => `[TRIZ][${l.t}ms] ${l.event} ${JSON.stringify({ ...l.data, ...l.state })}`).join('\\n');
                }
                
                try {
                    await navigator.clipboard.writeText(text);
                    console.log(`[TRIZ] copied ${logs.length} log lines to clipboard (${format})`);
                } catch (e) {
                    console.warn('[TRIZ] clipboard write failed, printing logs to console. Copy manually.', e);
                    console.log(text);
                }
            }
        };
        
        if (DEBUG_INTERACTION) {
            console.log('[TRIZ] Interaction debug enabled. Use TRIZDebug.copyLogs() or TRIZDebug.copyLogs(\"json\").');
        }
        
        // –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: –Ω–∞ —Å–ª–∞–±—ã—Ö –º–æ–±–∏–ª—å–Ω—ã—Ö —Ä–µ–∂–µ–º –Ω–∞–≥—Ä—É–∑–∫—É
        // 1) –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º DPR (–≤—ã—à–µ)
        // 2) –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º FPS
        const targetFPS = isMobile ? 30 : 60;
        const frameInterval = 1000 / targetFPS;
        let lastRenderTime = 0;
        
        // –§—É–Ω–∫—Ü–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è (–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ —É–±—Ä–∞–Ω–æ)
        function registerInteraction() {
            // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ
        }
        
        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à—å—é –∏ —Ç–∞—á–µ–º
        let isDragging = false;
        let isTouchDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationSpeed = 0.0042; // -40% –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤—Ä–∞—â–µ–Ω–∏—è –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
        let initialCameraZ = 7; // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –±–æ–ª–µ–µ –æ—Ç–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –≤–∏–¥–∞
        
        // –†–µ–∂–∏–º—ã –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è:
        // - selectedFaceIndex === -1: —Å–≤–æ–±–æ–¥–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞–∫ –≥–ª–æ–±—É—Å
        // - selectedFaceIndex >= 0: —Ä–µ–∂–∏–º –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≥—Ä–∞–Ω–∏ (–ø–∞–Ω + –∑—É–º –∫–∞–∫ –∫–∞—Ä—Ç–∞)
        const facePlaneDefaultZ = 6.75; // "–∫–∞—Ä—Ç–∞" –¥–∞–ª—å—à–µ (—É–º–µ–Ω—å—à–µ–Ω–æ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ –≤ 1.5 —Ä–∞–∑–∞)
        let panOffset = { x: 0, y: 0 };
        
        function setPan(x, y) {
            panOffset.x = x;
            panOffset.y = y;
            if (window.dodecahedron) {
                window.dodecahedron.position.set(panOffset.x, panOffset.y, 0);
            }
        }
        
        function resetFacePlaneView(faceIndex) {
            setPan(0, 0);
            camera.position.z = facePlaneDefaultZ;
            centerOnFace(faceIndex, true);
        }
        
        // –í—Ä–∞—â–µ–Ω–∏–µ –º—ã—à—å—é
        let mouseDownTime = 0;
        let mouseDownPosition = null;
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            logInteraction('mouse:down', { x: e.clientX, y: e.clientY, button: e.button });
            mouseDownTime = Date.now();
            mouseDownPosition = { x: e.clientX, y: e.clientY };
            previousMousePosition = { x: e.clientX, y: e.clientY };
            isDragging = false;
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (mouseDownPosition) {
                const moveDistance = Math.hypot(
                    e.clientX - mouseDownPosition.x,
                    e.clientY - mouseDownPosition.y
                );
                
                // –ï—Å–ª–∏ –º—ã—à—å –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª–∞—Å—å –±–æ–ª–µ–µ —á–µ–º –Ω–∞ 5 –ø–∏–∫—Å–µ–ª–µ–π - –Ω–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
                if (moveDistance > 5) {
                    isDragging = true;
                }
            }
            
            if (isDragging && window.dodecahedron) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                logInteraction(
                    'mouse:drag',
                    { dx: +deltaX.toFixed(2), dy: +deltaY.toFixed(2), x: e.clientX, y: e.clientY },
                    100
                );
                
                // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω–∞ –≥—Ä–∞–Ω—å (—Ä–µ–∂–∏–º –ø–ª–æ—Å–∫–æ—Å—Ç–∏) ‚Äî –¥–≤–∏–≥–∞–µ–º –∫–∞–∫ "–∫–∞—Ä—Ç—É" –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏
                if (selectedFaceIndex >= 0) {
                    // –ü–∏–∫—Å–µ–ª–∏ -> —É—Å–ª–æ–≤–Ω—ã–µ world units (–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –∑—É–º–∞)
                    const panFactor = 0.0022 * (camera.position.z / facePlaneDefaultZ);
                    const newX = panOffset.x + (deltaX * panFactor);
                    const newY = panOffset.y - (deltaY * panFactor);
                    
                    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ (—á—Ç–æ–±—ã –Ω–µ —É–µ—Ö–∞—Ç—å —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ)
                    const maxPan = 1.2 * (camera.position.z / facePlaneDefaultZ);
                    setPan(
                        Math.max(-maxPan, Math.min(maxPan, newX)),
                        Math.max(-maxPan, Math.min(maxPan, newY))
                    );
                } else {
                    // –°–≤–æ–±–æ–¥–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ (–≥–ª–æ–±—É—Å) ‚Äî —á–µ—Ä–µ–∑ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω—ã (–±–µ–∑ Euler, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ "—Å–∫–∞—á–∫–æ–≤")
                    // –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Ç—è–Ω–µ–º –≤–ø—Ä–∞–≤–æ => –º–æ–¥–µ–ª—å –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –≤–ø—Ä–∞–≤–æ
                    const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), +deltaX * rotationSpeed);
                    const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), +deltaY * rotationSpeed);
                    window.dodecahedron.quaternion.premultiply(qy);
                    window.dodecahedron.quaternion.premultiply(qx);
                    targetQuaternion.copy(window.dodecahedron.quaternion);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —á–∏—Ç–∞–µ–º–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–¥–ª—è –ª–æ–≥–æ–≤/–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏)
                    const euler = new THREE.Euler().setFromQuaternion(window.dodecahedron.quaternion);
                    targetRotation = { x: euler.x, y: euler.y, z: euler.z };
                    currentRotation = { x: euler.x, y: euler.y, z: euler.z };
                    
                    logInteraction('mouse:rotate', { dx: +deltaX.toFixed(2), dy: +deltaY.toFixed(2) }, 100);
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
                registerInteraction();
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            logInteraction('mouse:up', {});
            isDragging = false;
            // mouseDownPosition –ù–ï —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–¥–µ—Å—å: –∏–Ω–∞—á–µ click –Ω–µ –æ—Ç–ª–∏—á–∏—Ç drag –æ—Ç –∫–ª–∏–∫–∞
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
            mouseDownPosition = null;
        });

        // –ó—É–º –∫–æ–ª–µ—Å–∏–∫–æ–º –º—ã—à–∏
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(2, Math.min(10, camera.position.z));
            registerInteraction();
        });

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞—á–µ–º –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        let touchStart = null;
        let touchStartDistance = 0;
        let touchStartZoom = initialCameraZ;
        let lastTouchDistance = 0;
        let lastTouchAngle = 0;
        let touchStartRotation = { x: 0, y: 0, z: 0 };
        let isTwoFingerGesture = false;
        let touchStartCenter = null;

        // –§—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —É–≥–ª–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏
        function getAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // –§—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏
        function getCenter(x1, y1, x2, y2) {
            return {
                x: (x1 + x2) / 2,
                y: (y1 + y2) / 2
            };
        }

        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            logInteraction('touch:start', { touches: e.touches.length });
            
            if (e.touches.length === 2) {
                // –î–≤–∞ –ø–∞–ª—å—Ü–∞: –Ω–∞—á–∞–ª–æ –∂–µ—Å—Ç–∞ zoom/rotate
                isTwoFingerGesture = true;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –ø–∞–ª—å—Ü–∞–º–∏ –¥–ª—è –∑—É–º–∞
                touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                lastTouchDistance = touchStartDistance;
                touchStartZoom = camera.position.z;
                
                // –¶–µ–Ω—Ç—Ä –º–µ–∂–¥—É –ø–∞–ª—å—Ü–∞–º–∏
                touchStartCenter = getCenter(touch1.clientX, touch1.clientY, touch2.clientX, touch2.clientY);
                
                // –£–≥–æ–ª –º–µ–∂–¥—É –ø–∞–ª—å—Ü–∞–º–∏ –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è
                lastTouchAngle = getAngle(touch1.clientX, touch1.clientY, touch2.clientX, touch2.clientY);
                logInteraction('touch:2:start', { startAngle: +lastTouchAngle.toFixed(4) });
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
                if (window.dodecahedron) {
                    touchStartRotation = {
                        x: window.dodecahedron.rotation.x,
                        y: window.dodecahedron.rotation.y,
                        z: window.dodecahedron.rotation.z
                    };
                }
                
                registerInteraction();
            } else if (e.touches.length === 1) {
                // –û–¥–∏–Ω –ø–∞–ª–µ—Ü: –ø—Ä–æ—Å—Ç–æ–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è
                isTwoFingerGesture = false;
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                logInteraction('touch:1:start', { x: touchStart.x, y: touchStart.y });
                if (window.dodecahedron) {
                    touchStartRotation = {
                        x: window.dodecahedron.rotation.x,
                        y: window.dodecahedron.rotation.y,
                        z: window.dodecahedron.rotation.z
                    };
                }
                registerInteraction();
            }
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 2 && isTwoFingerGesture && window.dodecahedron) {
                // –î–≤–∞ –ø–∞–ª—å—Ü–∞: zoom –∏ rotate
                isTouchDragging = true;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Pinch-to-zoom: –≤—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –ø–∞–ª—å—Ü–∞–º–∏
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –∑—É–º - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
                if (lastTouchDistance > 0) {
                    const distanceDelta = currentDistance - lastTouchDistance;
                    const zoomSensitivity = 0.02;
                    camera.position.z -= distanceDelta * zoomSensitivity;
                    camera.position.z = Math.max(2, Math.min(10, camera.position.z));
                }
                
                // Rotate: –≤—ã—á–∏—Å–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —É–≥–ª–∞ –º–µ–∂–¥—É –ø–∞–ª—å—Ü–∞–º–∏
                const currentAngle = getAngle(touch1.clientX, touch1.clientY, touch2.clientX, touch2.clientY);
                let angleDelta = currentAngle - lastTouchAngle;
                logInteraction('touch:2:move', { angleDelta: +angleDelta.toFixed(4) }, 100);
                
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —É–≥–æ–ª –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-PI, PI]
                while (angleDelta > Math.PI) angleDelta -= 2 * Math.PI;
                while (angleDelta < -Math.PI) angleDelta += 2 * Math.PI;
                
                if (Math.abs(angleDelta) > 0.001) {
                    // –î–í–ê –ü–ê–õ–¨–¶–ê (twist): –ø–ª–æ—Å–∫–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞–∫ faceRotation (–≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —ç–∫—Ä–∞–Ω–∞),
                    // –∞ –Ω–µ –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Y.
                    // –¢–∞–∫–∂–µ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω–≤–µ—Ä—Å–∏—é (–ø–æ —á–∞—Å–æ–≤–æ–π => –ø–æ–≤–æ—Ä–æ—Ç –ø–æ —á–∞—Å–æ–≤–æ–π).
                    const rotationSensitivity = 0.72; // 1.2 * 0.6 (—Å–Ω–∏–∂–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –Ω–∞ 40%)
                    const worldAxis = new THREE.Vector3(0, 0, -1); // –æ—Å—å –≤–¥–æ–ª—å –≤–∑–≥–ª—è–¥–∞ –∫–∞–º–µ—Ä—ã
                    
                    const currentQuaternion = window.dodecahedron.quaternion.clone();
                    // –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ: –∫—Ä—É—Ç–∏–º –ø–æ —á–∞—Å–æ–≤–æ–π => –º–æ–¥–µ–ª—å –∫—Ä—É—Ç–∏—Ç—Å—è –ø–æ —á–∞—Å–æ–≤–æ–π
                    const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(worldAxis, +angleDelta * rotationSensitivity);
                    const newQuaternion = rotationQuaternion.multiply(currentQuaternion);
                    window.dodecahedron.quaternion.copy(newQuaternion);
                    targetQuaternion.copy(newQuaternion);
                    
                    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —á–∏—Ç–∞–µ–º–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–¥–ª—è –ª–æ–≥–æ–≤)
                    const euler = new THREE.Euler().setFromQuaternion(newQuaternion);
                    targetRotation = { x: euler.x, y: euler.y, z: euler.z };
                    currentRotation = { x: euler.x, y: euler.y, z: euler.z };
                    logInteraction('touch:2:rotate', { applied: +(angleDelta).toFixed(4) }, 100);
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
                lastTouchDistance = currentDistance;
                lastTouchAngle = currentAngle;
                registerInteraction();
                
            } else if (e.touches.length === 1 && touchStart && !isTwoFingerGesture && window.dodecahedron) {
                // –û–¥–∏–Ω –ø–∞–ª–µ—Ü: –ª–∏–±–æ –ø–∞–Ω –ø–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏ (–∫–∞–∫ –∫–∞—Ä—Ç–∞), –ª–∏–±–æ —Å–≤–æ–±–æ–¥–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                isTouchDragging = true;
                const deltaX = e.touches[0].clientX - touchStart.x;
                const deltaY = e.touches[0].clientY - touchStart.y;
                logInteraction('touch:1:move', { dx: +deltaX.toFixed(2), dy: +deltaY.toFixed(2) }, 100);
                
                if (selectedFaceIndex >= 0) {
                    // –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏
                    const panFactor = 0.0022 * (camera.position.z / facePlaneDefaultZ);
                    const newX = panOffset.x + (deltaX * panFactor);
                    const newY = panOffset.y - (deltaY * panFactor);
                    const maxPan = 1.2 * (camera.position.z / facePlaneDefaultZ);
                    setPan(
                        Math.max(-maxPan, Math.min(maxPan, newX)),
                        Math.max(-maxPan, Math.min(maxPan, newY))
                    );
                    // –î–µ–ª–∞–µ–º –ø–∞–Ω –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω—ã–º
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else {
                    // –í—Ä–∞—â–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ (—Å–≤–æ–±–æ–¥–Ω–æ) ‚Äî –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω—ã
                    const sensitivity = 0.006; // -40%
                    // –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Å–≤–∞–π–ø –≤–ø—Ä–∞–≤–æ => –º–æ–¥–µ–ª—å –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –≤–ø—Ä–∞–≤–æ
                    const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), +deltaX * sensitivity);
                    const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), +deltaY * sensitivity);
                    window.dodecahedron.quaternion.premultiply(qy);
                    window.dodecahedron.quaternion.premultiply(qx);
                    targetQuaternion.copy(window.dodecahedron.quaternion);
                    
                    const euler = new THREE.Euler().setFromQuaternion(window.dodecahedron.quaternion);
                    targetRotation = { x: euler.x, y: euler.y, z: euler.z };
                    currentRotation = { x: euler.x, y: euler.y, z: euler.z };
                    
                    // –¥–µ–ª–∞–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞–ª—å–Ω—ã–º: "—Ç–æ—á–∫–∞ —Å—Ç–∞—Ä—Ç–∞" ‚Äî —Ç–µ–∫—É—â–∞—è
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    
                    logInteraction('touch:1:rotate', { dx: +deltaX.toFixed(2), dy: +deltaY.toFixed(2) }, 100);
                }
                
                registerInteraction();
            }
        });

        renderer.domElement.addEventListener('touchend', (e) => {
            e.preventDefault();
            logInteraction('touch:end', { touches: e.touches.length });
            
            if (e.touches.length === 0) {
                // –í—Å–µ –ø–∞–ª—å—Ü—ã —É–±—Ä–∞–Ω—ã
                isTouchDragging = false;
                touchStart = null;
                touchStartDistance = 0;
                lastTouchDistance = 0;
                lastTouchAngle = 0;
                isTwoFingerGesture = false;
                touchStartRotation = { x: 0, y: 0, z: 0 };
                touchStartCenter = null;
            } else if (e.touches.length === 1) {
                // –û—Å—Ç–∞–ª—Å—è –æ–¥–∏–Ω –ø–∞–ª–µ—Ü - –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –æ–¥–Ω–æ-–ø–∞–ª—å—Ü–µ–≤—ã–π –∂–µ—Å—Ç
                isTwoFingerGesture = false;
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                if (window.dodecahedron) {
                    touchStartRotation = {
                        x: window.dodecahedron.rotation.x,
                        y: window.dodecahedron.rotation.y,
                        z: window.dodecahedron.rotation.z
                    };
                }
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –¥–≤—É—Ö–ø–∞–ª—å—Ü–µ–≤–æ–≥–æ –∂–µ—Å—Ç–∞
                lastTouchDistance = 0;
                lastTouchAngle = 0;
                touchStartCenter = null;
            }
        });

        // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑—É–º–æ–º
        document.getElementById('zoom-in').addEventListener('click', () => {
            camera.position.z = Math.max(2, camera.position.z - 0.5);
            registerInteraction();
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            camera.position.z = Math.min(10, camera.position.z + 0.5);
            registerInteraction();
        });

        // –°–±—Ä–æ—Å –≤–∏–¥–∞ - –≤–æ–∑–≤—Ä–∞—Ç –Ω–∞ –≥—Ä–∞–Ω—å 12
        document.getElementById('reset').addEventListener('click', () => {
            camera.position.set(0, 0, initialCameraZ);
            if (window.dodecahedron) {
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                deselectFace();
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –Ω–∞ –≥—Ä–∞–Ω–∏ 12 (–∏–Ω–¥–µ–∫—Å 11) —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º –ø–æ–≤–æ—Ä–æ—Ç–∞
                centerOnFace(11, true);
                // –í—ã–¥–µ–ª—è–µ–º –≥—Ä–∞–Ω—å 12
                selectFace(11);
            }
            registerInteraction();
        });

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∞–º–∏
        document.addEventListener('keydown', (e) => {
            if (window.dodecahedron) {
                switch(e.key) {
                    case 'ArrowLeft':
                        window.dodecahedron.rotation.y += 0.1;
                        registerInteraction();
                        break;
                    case 'ArrowRight':
                        window.dodecahedron.rotation.y -= 0.1;
                        registerInteraction();
                        break;
                    case 'ArrowUp':
                        window.dodecahedron.rotation.x += 0.1;
                        registerInteraction();
                        break;
                    case 'ArrowDown':
                        window.dodecahedron.rotation.x -= 0.1;
                        registerInteraction();
                        break;
                }
            }
        });


        function updateFaceListSelection() {
            if (!faceListElement) return;
            const items = faceListElement.querySelectorAll('.face-list-item');
            items.forEach((item) => {
                if (item.dataset.mode === 'globe') {
                    item.classList.toggle('active', selectedFaceIndex < 0);
                    return;
                }
                const faceIndex = parseInt(item.dataset.faceIndex);
                item.classList.toggle('active', faceIndex === selectedFaceIndex);
            });
        }

        function initFaceSelection() {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –≥—Ä–∞–Ω–∏
            renderer.domElement.addEventListener('click', (e) => {
                // –í —Ä–µ–∂–∏–º–µ –≥–ª–æ–±—É—Å–∞ –∫–ª–∏–∫–æ–º –ø–æ –º–æ–¥–µ–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–±–∏—Ä–∞–µ–º
                // (–ø–µ—Ä–µ—Ö–æ–¥ –≤ —Ä–µ–∂–∏–º "–∫–∞—Ä—Ç—ã" —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ —Å–ø–∏—Å–∫–∞ –≥—Ä–∞–Ω–µ–π)
                if (selectedFaceIndex < 0) {
                    mouseDownPosition = null;
                    return;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–æ –ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
                if (mouseDownPosition) {
                    const moveDistance = Math.hypot(
                        e.clientX - mouseDownPosition.x,
                        e.clientY - mouseDownPosition.y
                    );
                    
                    // –ï—Å–ª–∏ –±—ã–ª–æ –¥–≤–∏–∂–µ–Ω–∏–µ –±–æ–ª–µ–µ 5 –ø–∏–∫—Å–µ–ª–µ–π - —ç—Ç–æ –±—ã–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ, –Ω–µ –∫–ª–∏–∫
                    if (moveDistance > 5 || isDragging) {
                        mouseDownPosition = null;
                        return;
                    }
                }
                
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                if (window.dodecahedron) {
                    const intersects = raycaster.intersectObject(window.dodecahedron);
                    
                    if (intersects.length > 0) {
                        const faceIndex = intersects[0].face.materialIndex;
                        selectFace(faceIndex);
                        registerInteraction();
                    }
                }
                
                // –í –ª—é–±–æ–º —Å–ª—É—á–∞–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ "–Ω–∞–∂–∞—Ç–∏—è" –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∏–∫–∞
                mouseDownPosition = null;
            });

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–∞—á–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –≥—Ä–∞–Ω–∏ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
            let touchStartTime = 0;
            let touchStartPos = null;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartTime = Date.now();
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });

            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 1 && touchStartPos) {
                    // –í —Ä–µ–∂–∏–º–µ –≥–ª–æ–±—É—Å–∞ —Ç–∞–ø –ø–æ –º–æ–¥–µ–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–±–∏—Ä–∞–µ—Ç
                    if (selectedFaceIndex < 0) {
                        touchStartPos = null;
                        return;
                    }
                    
                    // –ï—Å–ª–∏ –±—ã–ª drag/rotate ‚Äî –Ω–µ —Ç—Ä–∞–∫—Ç—É–µ–º –∫–∞–∫ —Ç–∞–ø (–∏–Ω–∞—á–µ –ø–æ—Å–ª–µ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –±—ã–≤–∞—é—Ç —Ä—ã–≤–∫–∏/–ø–µ—Ä–µ—Ü–µ–Ω—Ç—Ä–æ–≤–∫–∞)
                    if (isTouchDragging) {
                        touchStartPos = null;
                        return;
                    }
                    
                    const touchEnd = e.changedTouches[0];
                    const touchDuration = Date.now() - touchStartTime;
                    const touchDistance = Math.hypot(
                        touchEnd.clientX - touchStartPos.x,
                        touchEnd.clientY - touchStartPos.y
                    );
                    
                    // –ï—Å–ª–∏ —ç—Ç–æ –∫–æ—Ä–æ—Ç–∫–æ–µ –∫–∞—Å–∞–Ω–∏–µ –±–µ–∑ –¥–≤–∏–∂–µ–Ω–∏—è - –≤—ã–±–∏—Ä–∞–µ–º –≥—Ä–∞–Ω—å
                    if (touchDuration < 300 && touchDistance < 10) {
                        mouse.x = (touchEnd.clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(touchEnd.clientY / window.innerHeight) * 2 + 1;
                        
                        raycaster.setFromCamera(mouse, camera);
                        
                        if (window.dodecahedron) {
                            const intersects = raycaster.intersectObject(window.dodecahedron);
                            
                            if (intersects.length > 0) {
                                const faceIndex = intersects[0].face.materialIndex;
                                selectFace(faceIndex);
                                registerInteraction();
                            }
                        }
                    }
                }
                
                touchStartPos = null;
            });
        }

        // –§—É–Ω–∫—Ü–∏—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≥—Ä–∞–Ω–∏
        function centerOnFace(faceIndex, applyRotation = false) {
            if (!window.dodecahedron || faceIndex < 0) return;
            
            const geometry = window.dodecahedron.geometry;
            if (!geometry.groups || geometry.groups.length === 0) return;
            
            const group = geometry.groups[faceIndex];
            if (!group) return;
            
            const positions = geometry.attributes.position;
            const indices = geometry.index;
            if (!positions || !indices) return;
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã –≥—Ä–∞–Ω–∏ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∞
            const faceVertices = [];
            const vertexSet = new Set();
            
            for (let i = 0; i < group.count; i++) {
                const indexPos = group.start + i;
                if (indexPos < indices.count) {
                    const vertexIndex = indices.getX(indexPos);
                    if (!vertexSet.has(vertexIndex)) {
                        vertexSet.add(vertexIndex);
                        faceVertices.push(new THREE.Vector3(
                            positions.getX(vertexIndex),
                            positions.getY(vertexIndex),
                            positions.getZ(vertexIndex)
                        ));
                    }
                }
            }
            
            if (faceVertices.length < 3) return;
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä –≥—Ä–∞–Ω–∏
            const faceCenter = new THREE.Vector3();
            faceVertices.forEach(v => faceCenter.add(v));
            faceCenter.divideScalar(faceVertices.length);
            
            // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ—Ä–º–∞–ª—å –≥—Ä–∞–Ω–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–µ 3 –≤–µ—Ä—à–∏–Ω—ã)
            const v0 = faceVertices[0];
            const v1 = faceVertices[1];
            const v2 = faceVertices[2];
            const edge1 = new THREE.Vector3().subVectors(v1, v0);
            const edge2 = new THREE.Vector3().subVectors(v2, v0);
            let faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∫–∞–º–µ—Ä–µ (–≤–¥–æ–ª—å –æ—Å–∏ Z, –Ω–æ –æ—Ç –æ–±—ä–µ–∫—Ç–∞ –∫ –∫–∞–º–µ—Ä–µ)
            const cameraDirection = new THREE.Vector3(0, 0, -1); // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ Z, —Ç–∞–∫ –∫–∞–∫ –∫–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –≤ -Z
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–æ—Ä–º–∞–ª—å
            // –ï—Å–ª–∏ –Ω–æ—Ä–º–∞–ª—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞, –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫ –∫–∞–º–µ—Ä–µ
            const toCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), faceCenter).normalize();
            if (faceNormal.dot(toCenter) < 0) {
                faceNormal.negate();
            }
            
            // –í—ã—á–∏—Å–ª—è–µ–º –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –Ω–æ—Ä–º–∞–ª–∏ –≥—Ä–∞–Ω–∏ –∫ –∫–∞–º–µ—Ä–µ
            let quaternion = new THREE.Quaternion().setFromUnitVectors(faceNormal, cameraDirection);
            
            // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –ø–æ–≤–æ—Ä–æ—Ç –≥—Ä–∞–Ω–∏, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ —Å—Ä–∞–∑—É
            if (applyRotation && faceAutoRotations && faceAutoRotations[faceIndex] !== undefined) {
                let rotationAngle = faceAutoRotations[faceIndex] || 0;
                // –¢–æ–Ω–∫–∞—è –¥–æ–∫—Ä—É—Ç–∫–∞ –ø–æ –≤–∞—à–µ–º—É —Å–ø–∏—Å–∫—É (¬±5¬∞/¬±15¬∞)
                if (typeof faceFineRotations !== 'undefined' && faceFineRotations[faceIndex] !== undefined) {
                    rotationAngle += faceFineRotations[faceIndex];
                }
                
                if (rotationAngle !== 0) {
                    const worldAxis = new THREE.Vector3(0, 0, -1);
                    const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(worldAxis, rotationAngle);
                    quaternion = rotationQuaternion.multiply(quaternion);
                }
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º targetQuaternion –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
            targetQuaternion.copy(quaternion);
            // –î–µ—Ä–∂–∏–º targetRotation —Ç–æ–ª—å–∫–æ –∫–∞–∫ "—á–∏—Ç–∞–µ–º–æ–µ" –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–Ω–µ –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã)
            const euler = new THREE.Euler().setFromQuaternion(quaternion);
            targetRotation = { x: euler.x, y: euler.y, z: euler.z };
            
            // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º currentRotation (–¥–ª—è –ª–æ–≥–æ–≤)
            currentRotation = { 
                x: window.dodecahedron.rotation.x, 
                y: window.dodecahedron.rotation.y, 
                z: window.dodecahedron.rotation.z 
            };
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
            isCentering = true;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏
        function initTextureControls() {
            if (!window.textureSettings) {
                window.textureSettings = {};
            }
            
            const texturePanel = document.getElementById('texture-controls-panel');
            if (!texturePanel) return;
            
            // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç—É—Ä –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≥—Ä–∞–Ω–∏
            function updateTextureForFace(faceIndex) {
                if (!window.dodecahedron || !window.dodecahedronMaterials) return;
                
                const materials = Array.isArray(window.dodecahedron.material) 
                    ? window.dodecahedron.material 
                    : [window.dodecahedron.material];
                
                if (faceIndex < 0 || faceIndex >= materials.length) return;
                
                const material = materials[faceIndex];
                const texture = material?.map;
                if (!texture) return;
                
                const orientation = window.faceOrientations && window.faceOrientations[faceIndex] 
                    ? window.faceOrientations[faceIndex] 
                    : { rotation: 0, flipX: false, flipY: false };
                const faceSettings = window.textureSettings[faceIndex] || { rotation: 0, offsetX: 0, offsetY: 0, scale: 1.0 };
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                texture.offset.set(0, 0);
                texture.repeat.set(1, 1);
                texture.center.set(0.5, 0.5);
                texture.rotation = 0;
                
                // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ
                texture.offset.x = 1;
                texture.repeat.x = -1;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–± (—á–µ—Ä–µ–∑ repeat)
                // scale > 1 = —É–≤–µ–ª–∏—á–µ–Ω–∏–µ (—É–º–µ–Ω—å—à–∞–µ–º repeat)
                // scale < 1 = —É–º–µ–Ω—å—à–µ–Ω–∏–µ (—É–≤–µ–ª–∏—á–∏–≤–∞–µ–º repeat)
                const scale = faceSettings.scale || 1.0;
                texture.repeat.set(-1 / scale, 1 / scale);
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –∏ —Å–º–µ—â–µ–Ω–∏–µ
                texture.rotation = (orientation.rotation || 0) + faceSettings.rotation;
                texture.offset.x = 1 + faceSettings.offsetX;
                texture.offset.y = faceSettings.offsetY;
                
                texture.needsUpdate = true;
                updateTexturePanel(faceIndex);
            }
            
            // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            function updateTexturePanel(faceIndex) {
                const faceSettings = window.textureSettings[faceIndex] || { rotation: 0, offsetX: 0, offsetY: 0, scale: 1.0 };
                
                document.getElementById('texture-face-number').textContent = faceIndex + 1;
                document.getElementById('texture-rotation-value').textContent = 
                    (faceSettings.rotation * 180 / Math.PI).toFixed(1) + '¬∞';
                document.getElementById('texture-offset-x-value').textContent = faceSettings.offsetX.toFixed(3);
                document.getElementById('texture-offset-y-value').textContent = faceSettings.offsetY.toFixed(3);
                document.getElementById('texture-scale-value').textContent = (faceSettings.scale || 1.0).toFixed(2);
                
                // –í—ã–≤–æ–¥–∏–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
                const output = document.getElementById('texture-values-output');
                if (output) {
                    output.textContent = `–ì—Ä–∞–Ω—å ${faceIndex + 1}: rotation: ${faceSettings.rotation.toFixed(6)}, offsetX: ${faceSettings.offsetX.toFixed(6)}, offsetY: ${faceSettings.offsetY.toFixed(6)}, scale: ${(faceSettings.scale || 1.0).toFixed(6)}`;
                }
            }
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ —Å –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä–æ–º –ø—Ä–∏ –∑–∞–∂–∞—Ç–∏–∏
            const stepRotation = Math.PI / 180; // 1 –≥—Ä–∞–¥—É—Å
            const stepOffset = 0.01; // –®–∞–≥ —Å–º–µ—â–µ–Ω–∏—è
            const stepScale = 0.05; // –®–∞–≥ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è (5%)
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≥—Ä–∞–Ω–∏
            function getOrCreateFaceSettings(faceIndex) {
                if (!window.textureSettings[faceIndex]) {
                    window.textureSettings[faceIndex] = { rotation: 0, offsetX: 0, offsetY: 0, scale: 1.0 };
                }
                return window.textureSettings[faceIndex];
            }
            
            // –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏
            let autoRepeatInterval = null;
            let autoRepeatTimeout = null;
            let currentAction = null;
            
            function startAutoRepeat(action) {
                // –í—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ —Å—Ä–∞–∑—É
                action();
                
                // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä–∞ (300ms)
                autoRepeatTimeout = setTimeout(() => {
                    // –ú–µ–¥–ª–µ–Ω–Ω—ã–π –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä (100ms)
                    autoRepeatInterval = setInterval(() => {
                        action();
                    }, 100);
                }, 300);
            }
            
            function stopAutoRepeat() {
                if (autoRepeatTimeout) {
                    clearTimeout(autoRepeatTimeout);
                    autoRepeatTimeout = null;
                }
                if (autoRepeatInterval) {
                    clearInterval(autoRepeatInterval);
                    autoRepeatInterval = null;
                }
                currentAction = null;
            }
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å –∞–≤—Ç–æ–ø–æ–≤—Ç–æ—Ä–æ–º
            function createAutoRepeatHandler(action) {
                return {
                    start: () => {
                        if (selectedFaceIndex < 0) return;
                        currentAction = action;
                        startAutoRepeat(action);
                    },
                    stop: () => {
                        stopAutoRepeat();
                    }
                };
            }
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –ø–æ–≤–æ—Ä–æ—Ç–∞
            const rotateLeftHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                getOrCreateFaceSettings(selectedFaceIndex).rotation -= stepRotation;
                updateTextureForFace(selectedFaceIndex);
            });
            
            const rotateRightHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                getOrCreateFaceSettings(selectedFaceIndex).rotation += stepRotation;
                updateTextureForFace(selectedFaceIndex);
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Å–º–µ—â–µ–Ω–∏—è X
            const offsetXLeftHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                getOrCreateFaceSettings(selectedFaceIndex).offsetX -= stepOffset;
                updateTextureForFace(selectedFaceIndex);
            });
            
            const offsetXRightHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                getOrCreateFaceSettings(selectedFaceIndex).offsetX += stepOffset;
                updateTextureForFace(selectedFaceIndex);
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Å–º–µ—â–µ–Ω–∏—è Y
            const offsetYDownHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                getOrCreateFaceSettings(selectedFaceIndex).offsetY -= stepOffset;
                updateTextureForFace(selectedFaceIndex);
            });
            
            const offsetYUpHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                getOrCreateFaceSettings(selectedFaceIndex).offsetY += stepOffset;
                updateTextureForFace(selectedFaceIndex);
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –º–∞—Å—à—Ç–∞–±–∞
            const scaleDownHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                const settings = getOrCreateFaceSettings(selectedFaceIndex);
                settings.scale = Math.max(0.1, (settings.scale || 1.0) - stepScale);
                updateTextureForFace(selectedFaceIndex);
            });
            
            const scaleUpHandler = createAutoRepeatHandler(() => {
                if (selectedFaceIndex < 0) return;
                const settings = getOrCreateFaceSettings(selectedFaceIndex);
                settings.scale = Math.min(5.0, (settings.scale || 1.0) + stepScale);
                updateTextureForFace(selectedFaceIndex);
            });
            
            // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫ –∫–Ω–æ–ø–∫–∞–º
            const rotateLeftBtn = document.getElementById('texture-rotate-left');
            const rotateRightBtn = document.getElementById('texture-rotate-right');
            const offsetXLeftBtn = document.getElementById('texture-offset-x-left');
            const offsetXRightBtn = document.getElementById('texture-offset-x-right');
            const offsetYDownBtn = document.getElementById('texture-offset-y-down');
            const offsetYUpBtn = document.getElementById('texture-offset-y-up');
            const scaleDownBtn = document.getElementById('texture-scale-down');
            const scaleUpBtn = document.getElementById('texture-scale-up');
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –º—ã—à–∏
            rotateLeftBtn.addEventListener('mousedown', rotateLeftHandler.start);
            rotateLeftBtn.addEventListener('mouseup', rotateLeftHandler.stop);
            rotateLeftBtn.addEventListener('mouseleave', rotateLeftHandler.stop);
            
            rotateRightBtn.addEventListener('mousedown', rotateRightHandler.start);
            rotateRightBtn.addEventListener('mouseup', rotateRightHandler.stop);
            rotateRightBtn.addEventListener('mouseleave', rotateRightHandler.stop);
            
            offsetXLeftBtn.addEventListener('mousedown', offsetXLeftHandler.start);
            offsetXLeftBtn.addEventListener('mouseup', offsetXLeftHandler.stop);
            offsetXLeftBtn.addEventListener('mouseleave', offsetXLeftHandler.stop);
            
            offsetXRightBtn.addEventListener('mousedown', offsetXRightHandler.start);
            offsetXRightBtn.addEventListener('mouseup', offsetXRightHandler.stop);
            offsetXRightBtn.addEventListener('mouseleave', offsetXRightHandler.stop);
            
            offsetYDownBtn.addEventListener('mousedown', offsetYDownHandler.start);
            offsetYDownBtn.addEventListener('mouseup', offsetYDownHandler.stop);
            offsetYDownBtn.addEventListener('mouseleave', offsetYDownHandler.stop);
            
            offsetYUpBtn.addEventListener('mousedown', offsetYUpHandler.start);
            offsetYUpBtn.addEventListener('mouseup', offsetYUpHandler.stop);
            offsetYUpBtn.addEventListener('mouseleave', offsetYUpHandler.stop);
            
            scaleDownBtn.addEventListener('mousedown', scaleDownHandler.start);
            scaleDownBtn.addEventListener('mouseup', scaleDownHandler.stop);
            scaleDownBtn.addEventListener('mouseleave', scaleDownHandler.stop);
            
            scaleUpBtn.addEventListener('mousedown', scaleUpHandler.start);
            scaleUpBtn.addEventListener('mouseup', scaleUpHandler.stop);
            scaleUpBtn.addEventListener('mouseleave', scaleUpHandler.stop);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Ç–∞—á-—É—Å—Ç—Ä–æ–π—Å—Ç–≤
            rotateLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); rotateLeftHandler.start(); });
            rotateLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); rotateLeftHandler.stop(); });
            rotateLeftBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); rotateLeftHandler.stop(); });
            
            rotateRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); rotateRightHandler.start(); });
            rotateRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); rotateRightHandler.stop(); });
            rotateRightBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); rotateRightHandler.stop(); });
            
            offsetXLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); offsetXLeftHandler.start(); });
            offsetXLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); offsetXLeftHandler.stop(); });
            offsetXLeftBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); offsetXLeftHandler.stop(); });
            
            offsetXRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); offsetXRightHandler.start(); });
            offsetXRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); offsetXRightHandler.stop(); });
            offsetXRightBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); offsetXRightHandler.stop(); });
            
            offsetYDownBtn.addEventListener('touchstart', (e) => { e.preventDefault(); offsetYDownHandler.start(); });
            offsetYDownBtn.addEventListener('touchend', (e) => { e.preventDefault(); offsetYDownHandler.stop(); });
            offsetYDownBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); offsetYDownHandler.stop(); });
            
            offsetYUpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); offsetYUpHandler.start(); });
            offsetYUpBtn.addEventListener('touchend', (e) => { e.preventDefault(); offsetYUpHandler.stop(); });
            offsetYUpBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); offsetYUpHandler.stop(); });
            
            scaleDownBtn.addEventListener('touchstart', (e) => { e.preventDefault(); scaleDownHandler.start(); });
            scaleDownBtn.addEventListener('touchend', (e) => { e.preventDefault(); scaleDownHandler.stop(); });
            scaleDownBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); scaleDownHandler.stop(); });
            
            scaleUpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); scaleUpHandler.start(); });
            scaleUpBtn.addEventListener('touchend', (e) => { e.preventDefault(); scaleUpHandler.stop(); });
            scaleUpBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); scaleUpHandler.stop(); });
            
            document.getElementById('texture-reset').addEventListener('click', () => {
                if (selectedFaceIndex < 0) return;
                window.textureSettings[selectedFaceIndex] = { rotation: 0, offsetX: 0, offsetY: 0, scale: 1.0 };
                updateTextureForFace(selectedFaceIndex);
            });
            
            document.getElementById('texture-copy-values').addEventListener('click', () => {
                if (selectedFaceIndex < 0) return;
                const faceSettings = window.textureSettings[selectedFaceIndex] || { rotation: 0, offsetX: 0, offsetY: 0, scale: 1.0 };
                const code = `window.textureSettings[${selectedFaceIndex}] = { rotation: ${faceSettings.rotation.toFixed(6)}, offsetX: ${faceSettings.offsetX.toFixed(6)}, offsetY: ${faceSettings.offsetY.toFixed(6)}, scale: ${(faceSettings.scale || 1.0).toFixed(6)} };`;
                navigator.clipboard.writeText(code).then(() => {
                    alert('–ó–Ω–∞—á–µ–Ω–∏—è —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!');
                }).catch(() => {
                    console.log(code);
                    alert('–ó–Ω–∞—á–µ–Ω–∏—è –≤—ã–≤–µ–¥–µ–Ω—ã –≤ –∫–æ–Ω—Å–æ–ª—å');
                });
            });
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞–Ω–µ–ª–∏
            window.updateTextureForFace = updateTextureForFace;
            window.updateTexturePanel = updateTexturePanel;
        }
        
        function selectFace(faceIndex) {
            const materials = Array.isArray(window.dodecahedron.material) 
                ? window.dodecahedron.material 
                : [window.dodecahedron.material];
            
            // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥—Ä–∞–Ω–∏
            if (selectedFaceIndex >= 0 && materials[selectedFaceIndex]) {
                if (materials[selectedFaceIndex].emissive) {
                    materials[selectedFaceIndex].emissive.setHex(0x000000);
                    materials[selectedFaceIndex].emissiveIntensity = 0;
                }
            }
            
            // –í—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é –≥—Ä–∞–Ω—å (–±–µ–∑ –ø–æ–¥—Å–≤–µ—Ç–∫–∏)
            selectedFaceIndex = faceIndex;
            
            // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Ä–µ–∂–∏–º –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏: "–∫–∞—Ä—Ç–∞"
            setPan(0, 0);
            camera.position.z = facePlaneDefaultZ;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤ —Å–ø–∏—Å–∫–µ –≥—Ä–∞–Ω–µ–π
            updateFaceListSelection();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≥—Ä–∞–Ω—å—é
            faceControlsPanel.classList.add('active');
        }

        function deselectFace() {
            const materials = Array.isArray(window.dodecahedron.material) 
                ? window.dodecahedron.material 
                : [window.dodecahedron.material];
            
            if (selectedFaceIndex >= 0 && materials[selectedFaceIndex] && materials[selectedFaceIndex].emissive) {
                materials[selectedFaceIndex].emissive.setHex(0x000000);
                materials[selectedFaceIndex].emissiveIntensity = 0;
            }
            selectedFaceIndex = -1;
            // –í–æ–∑–≤—Ä–∞—Ç –≤ —Ä–µ–∂–∏–º –≥–ª–æ–±—É—Å–∞
            setPan(0, 0);
            camera.position.z = initialCameraZ;
            faceControlsPanel.classList.remove('active');
            updateFaceListSelection();
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â—É—é –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
        // –í–∞–∂–Ω–æ: —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å "—Å–∫–∞—á–∫–æ–≤" –∏–∑-–∑–∞ –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç–∏ Euler-—É–≥–ª–æ–≤,
        // —Ö—Ä–∞–Ω–∏–º —Ü–µ–ª—å –≤ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–µ –∏ –∏–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω—ã –Ω–∞–ø—Ä—è–º—É—é.
        let targetRotation = { x: 0, y: 0, z: 0 }; // –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–æ—á–Ω—ã—Ö/—Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –Ω—É–∂–¥
        let currentRotation = { x: 0, y: 0, z: 0 }; // –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–æ—á–Ω—ã—Ö/—Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –Ω—É–∂–¥
        const targetQuaternion = new THREE.Quaternion();
        const smoothRotationSpeed = 0.1; // –°–∫–æ—Ä–æ—Å—Ç—å –ø–ª–∞–≤–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è
        let isCentering = false; // –§–ª–∞–≥, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, —á—Ç–æ –∏–¥–µ—Ç —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
        const faceRotationStep = (2 * Math.PI) / 10; // 36¬∞: –ø–æ–ª–Ω—ã–π –æ–±–æ—Ä–æ—Ç –∑–∞ 10 —à–∞–≥–æ–≤
        
        // –ú–∞—Å—Å–∏–≤ –ø–æ–≤–æ—Ä–æ—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä–∞–Ω–∏ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ (–∏–Ω–¥–µ–∫—Å—ã 0-11 —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –≥—Ä–∞–Ω—è–º 1-12)
        // –ö–∞–∂–¥—ã–π —à–∞–≥ = 36¬∞ (2œÄ/10 —Ä–∞–¥–∏–∞–Ω)
        const faceAutoRotations = [
            -1 * faceRotationStep,  // –ì—Ä–∞–Ω—å 1: 1 –≤–ª–µ–≤–æ
            +1 * faceRotationStep,   // –ì—Ä–∞–Ω—å 2: 1 –≤–ø—Ä–∞–≤–æ
            +1 * faceRotationStep,   // –ì—Ä–∞–Ω—å 3: 1 –≤–ø—Ä–∞–≤–æ
            0,                       // –ì—Ä–∞–Ω—å 4: –±–µ–∑ –ø–æ–≤–æ—Ä–æ—Ç–∞
            +2 * faceRotationStep,   // –ì—Ä–∞–Ω—å 5: 2 –≤–ø—Ä–∞–≤–æ
            -4 * faceRotationStep,   // –ì—Ä–∞–Ω—å 6: 4 –≤–ª–µ–≤–æ
            -1 * faceRotationStep,   // –ì—Ä–∞–Ω—å 7: 1 –≤–ª–µ–≤–æ
            +1 * faceRotationStep,   // –ì—Ä–∞–Ω—å 8: 1 –≤–ø—Ä–∞–≤–æ
            -5 * faceRotationStep,   // –ì—Ä–∞–Ω—å 9: 5 –≤–ª–µ–≤–æ
            0,                       // –ì—Ä–∞–Ω—å 10: –±–µ–∑ –ø–æ–≤–æ—Ä–æ—Ç–∞
            -2 * faceRotationStep,  // –ì—Ä–∞–Ω—å 11: 2 –≤–ª–µ–≤–æ
            0                        // –ì—Ä–∞–Ω—å 12: –±–µ–∑ –ø–æ–≤–æ—Ä–æ—Ç–∞
        ];
        
        // –¢–æ–Ω–∫–∞—è –¥–æ–∫—Ä—É—Ç–∫–∞ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö) –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –≥—Ä–∞–Ω–∏ –ø–æ –Ω–æ–º–µ—Ä—É.
        // –ó–Ω–∞–∫ –∫–∞–∫ –≤ rotateFace(angle): "–≤–ª–µ–≤–æ" = –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —É–≥–æ–ª, "–≤–ø—Ä–∞–≤–æ" = –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π.
        const deg = Math.PI / 180;
        const faceFineRotations = [
            0 * deg,    // 1: –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            -5 * deg,   // 2: –≤–ª–µ–≤–æ 5¬∞
            -15 * deg,  // 3: –≤–ª–µ–≤–æ 15¬∞
            -15 * deg,  // 4: –≤–ª–µ–≤–æ 15¬∞
            -5 * deg,   // 5: –≤–ª–µ–≤–æ 5¬∞
            0 * deg,    // 6: –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            +5 * deg,   // 7: –≤–ø—Ä–∞–≤–æ 5¬∞
            -15 * deg,  // 8: –≤–ª–µ–≤–æ 15¬∞
            0 * deg,    // 9: –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            -15 * deg,  // 10: –≤–ª–µ–≤–æ 15¬∞
            +5 * deg,   // 11: –≤–ø—Ä–∞–≤–æ 5¬∞
            0 * deg     // 12: –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        ];
        
        function rotateFace(angle) {
            if (selectedFaceIndex < 0 || !window.dodecahedron) return;
            
            // –ü–æ—Å–ª–µ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–æ—Ä–º–∞–ª—å –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≥—Ä–∞–Ω–∏ –≤—ã—Ä–æ–≤–Ω–µ–Ω–∞ —Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫–∞–º–µ—Ä—ã (0,0,-1)
            // –ü–æ—ç—Ç–æ–º—É, —á—Ç–æ–±—ã –∫—Ä—É—Ç–∏—Ç—å –≥—Ä–∞–Ω—å –∫–∞–∫ ¬´–º–æ–Ω–µ—Ç–∫—É¬ª –∏ –Ω–µ —É–≤–æ–¥–∏—Ç—å –µ—ë –∏–∑ —Ü–µ–Ω—Ç—Ä–∞,
            // –≤—Ä–∞—â–∞–µ–º –≤–µ—Å—å –¥–æ–¥–µ–∫–∞—ç–¥—Ä –≤–æ–∫—Ä—É–≥ –ú–ò–†–û–í–û–ô –æ—Å–∏, —Å–æ–≤–ø–∞–¥–∞—é—â–µ–π —Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫–∞–º–µ—Ä—ã.
            const worldAxis = new THREE.Vector3(0, 0, -1); // –æ—Å—å –≤–¥–æ–ª—å –≤–∑–≥–ª—è–¥–∞ –∫–∞–º–µ—Ä—ã
            
            const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(worldAxis, angle);
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫ –¶–ï–õ–ï–í–û–ú–£ –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω—É, —á—Ç–æ–±—ã –∞–Ω–∏–º–∞—Ü–∏—è –±—ã–ª–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π
            targetQuaternion.premultiply(rotationQuaternion);
            
            const euler = new THREE.Euler().setFromQuaternion(targetQuaternion);
            targetRotation = { x: euler.x, y: euler.y, z: euler.z };
            
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø–ª–∞–≤–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è
        function smoothRotate() {
            if (!window.dodecahedron) return;

            // –ù–µ –≤–º–µ—à–∏–≤–∞–µ–º—Å—è –≤ —Ä—É—á–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –º—ã—à—å—é/—Ç–∞—á–µ–º, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ ¬´—Ä—ã–≤–∫–æ–≤¬ª
            if (isDragging || isDraggingForRotation || isTouchDragging) return;
            
            // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–æ–≤ (–±–µ–∑ Euler –∫–∞–∫ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∏—Å—Ç–∏–Ω—ã)
            const distance = window.dodecahedron.quaternion.angleTo(targetQuaternion);
            if (distance > 0.001) {
                window.dodecahedron.quaternion.slerp(targetQuaternion, smoothRotationSpeed);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —á–∏—Ç–∞–µ–º–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–¥–ª—è –ª–æ–≥–æ–≤)
                const euler = new THREE.Euler().setFromQuaternion(window.dodecahedron.quaternion);
                currentRotation = { x: euler.x, y: euler.y, z: euler.z };
            } else if (isCentering) {
                // –ê–Ω–∏–º–∞—Ü–∏—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞
                isCentering = false;
                // –í—ã–∑—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
                window.dispatchEvent(new CustomEvent('faceCentered'));
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
        let centeringCallback = null; // –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–≤–æ–π–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
        function waitForCentering(callback) {
            // –ï—Å–ª–∏ —É–∂–µ –∏–¥–µ—Ç –æ–∂–∏–¥–∞–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –≤—ã–∑–æ–≤
            if (centeringCallback) {
                return;
            }
            
            centeringCallback = callback;
            isCentering = true;
            const checkInterval = setInterval(() => {
                if (!isCentering && centeringCallback) {
                    clearInterval(checkInterval);
                    const cb = centeringCallback;
                    centeringCallback = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–µ—Ä–µ–¥ –≤—ã–∑–æ–≤–æ–º
                    // –ù–µ–±–æ–ª—å—à–∞—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–æ–ª–Ω–æ–π —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏
                    setTimeout(cb, 200);
                }
            }, 50); // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 50ms
            
            // –¢–∞–π–º–∞—É—Ç –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è –Ω–µ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è
            setTimeout(() => {
                clearInterval(checkInterval);
                if (centeringCallback) {
                    const cb = centeringCallback;
                    centeringCallback = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–µ—Ä–µ–¥ –≤—ã–∑–æ–≤–æ–º
                    isCentering = false;
                    cb();
                }
            }, 3000); // –ú–∞–∫—Å–∏–º—É–º 3 —Å–µ–∫—É–Ω–¥—ã
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ –≤—Ä–∞—â–µ–Ω–∏—è –≥—Ä–∞–Ω–∏
        document.getElementById('face-rotate-left').addEventListener('click', () => {
            // –í—Ä–∞—â–µ–Ω–∏–µ –Ω–∞ 72¬∞ –≤–ª–µ–≤–æ: –ø–æ–ª–Ω—ã–π –æ–±–æ—Ä–æ—Ç –∑–∞ 5 –∫–ª–∏–∫–æ–≤
            rotateFace(-faceRotationStep);
            registerInteraction();
        });

        document.getElementById('face-rotate-right').addEventListener('click', () => {
            // –í—Ä–∞—â–µ–Ω–∏–µ –Ω–∞ 72¬∞ –≤–ø—Ä–∞–≤–æ: –ø–æ–ª–Ω—ã–π –æ–±–æ—Ä–æ—Ç –∑–∞ 5 –∫–ª–∏–∫–æ–≤
            rotateFace(faceRotationStep);
            registerInteraction();
        });

        document.getElementById('face-deselect').addEventListener('click', () => {
            deselectFace();
            registerInteraction();
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ø–∏—Å–∫–∞ –≥—Ä–∞–Ω–µ–π (–Ω–æ–º–µ—Ä–∞ 1‚Äì12)
        function initFaceList() {
            try {
                if (!faceListElement) {
                    console.warn('faceListElement –Ω–µ –Ω–∞–π–¥–µ–Ω');
                    return;
                }
                
                faceListElement.innerHTML = '';

                // –ö–Ω–æ–ø–∫–∞ üåê (—Å–≤–æ–±–æ–¥–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –∫–∞–∫ –≥–ª–æ–±—É—Å)
                const globeBtn = document.createElement('button');
                globeBtn.className = 'face-list-item';
                globeBtn.textContent = 'üåê';
                globeBtn.title = '–°–≤–æ–±–æ–¥–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ (–≥–ª–æ–±—É—Å)';
                globeBtn.dataset.mode = 'globe';
                globeBtn.addEventListener('click', () => {
                    deselectFace(); // –≤–µ—Ä–Ω—ë—Ç –≤ –≥–ª–æ–±—É—Å + —Å–±—Ä–æ—Å–∏—Ç –ø–∞–Ω/–∑—É–º
                    // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –ø–æ–≤–æ—Ä–æ—Ç –º–æ–¥–µ–ª–∏ –∫–∞–∫ –µ—Å—Ç—å (–º–æ–∂–Ω–æ –≤—Ä–∞—â–∞—Ç—å –¥–∞–ª—å—à–µ)
                    registerInteraction();
                });
                faceListElement.appendChild(globeBtn);
                
                for (let i = 0; i < 12; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'face-list-item';
                    btn.textContent = String(i + 1);
                    btn.dataset.faceIndex = i.toString();
                    
                    btn.addEventListener('click', () => {
                        // –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –∫–ª–∏–∫ –ø–æ —Ç–æ–π –∂–µ –≥—Ä–∞–Ω–∏: –≤–µ—Ä–Ω—É—Ç—å –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
                        if (selectedFaceIndex === i) {
                            resetFacePlaneView(i);
                            registerInteraction();
                            return;
                        }
                        
                        // –ü—Ä–∏ –≤—ã–±–æ—Ä–µ –∏–∑ —Å–ø–∏—Å–∫–∞: –≤–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏ (–ø–∞–Ω/–∑—É–º –∫–∞–∫ –∫–∞—Ä—Ç–∞)
                        selectFace(i);
                        resetFacePlaneView(i);
                        registerInteraction();
                    });
                    
                    faceListElement.appendChild(btn);
                }
                
                // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–∫—Ç–∏–≤–µ–Ω –≥–ª–æ–±—É—Å (–∞ –Ω–µ –≥—Ä–∞–Ω—å)
                selectedFaceIndex = -1;
                updateFaceListSelection();
                
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ initFaceList:', e);
            }
        }

        // –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –ø–æ—Å–ª–µ —Ä–µ—Å–∞–π–∑–∞/–ø–æ–≤–æ—Ä–æ—Ç–∞ —ç–∫—Ä–∞–Ω–∞
            const maxDPR = isMobile ? 1.25 : 2.0;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, maxDPR));
        });

        // –ê–Ω–∏–º–∞—Ü–∏—è
        let renderCallCount = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º FPS –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
            if (isMobile) {
                if (time - lastRenderTime < frameInterval) return;
                lastRenderTime = time;
            }
            
            // –ü–ª–∞–≤–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –¥–æ–¥–µ–∫–∞—ç–¥—Ä–∞
            smoothRotate();
            
            renderer.render(scene, camera);
            renderCallCount++;
            
            // –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã—Ö "—Å–∫–∞—á–∫–æ–≤" –≤—Ä–∞—â–µ–Ω–∏—è (—Ä–µ–¥–∫–æ, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å)
            if (DEBUG_INTERACTION && window.dodecahedron && renderCallCount % 30 === 0) {
                const r = window.dodecahedron.rotation;
                logInteraction('frame:state', { note: 'sample' });
            }
            
            // #region agent log
            if (DEBUG && (renderCallCount <= 3 || renderCallCount % 60 === 0)) {
                const gl = renderer.getContext();
                const frustum = new THREE.Frustum();
                const matrix = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                frustum.setFromProjectionMatrix(matrix);
                const dodecahedronInFrustum = window.dodecahedron ? frustum.intersectsObject(window.dodecahedron) : false;
                const dodecahedronBoundingBox = window.dodecahedron ? new THREE.Box3().setFromObject(window.dodecahedron) : null;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –≤ —Å—Ü–µ–Ω–µ
                const sceneObjects = [];
                scene.children.forEach((child, index) => {
                    if (child instanceof THREE.Mesh) {
                        const bbox = new THREE.Box3().setFromObject(child);
                        const inFrustum = frustum.intersectsObject(child);
                        const material = Array.isArray(child.material) ? child.material[0] : child.material;
                        sceneObjects.push({
                            index: index,
                            type: child.geometry?.type || 'unknown',
                            visible: child.visible,
                            inFrustum: inFrustum,
                            position: {x: child.position.x, y: child.position.y, z: child.position.z},
                            scale: {x: child.scale.x, y: child.scale.y, z: child.scale.z},
                            materialType: material?.type,
                            materialColor: material?.color?.getHex(),
                            bboxSize: {x: bbox.getSize(new THREE.Vector3()).x, y: bbox.getSize(new THREE.Vector3()).y, z: bbox.getSize(new THREE.Vector3()).z}
                        });
                    }
                });
                
            }
        }
        
        console.log('–ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏...');
        console.log('–°—Ü–µ–Ω–∞:', scene);
        console.log('–ö–∞–º–µ—Ä–∞:', camera);
        console.log('–†–µ–Ω–¥–µ—Ä–µ—Ä:', renderer);
        
        
        animate(performance.now());
    </script>
</body>
</html>